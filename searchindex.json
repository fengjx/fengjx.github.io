{"categories":[{"title":"java","uri":"https://blog.fengjx.com/categories/java/"},{"title":"linux常用命令","uri":"https://blog.fengjx.com/categories/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"mysql","uri":"https://blog.fengjx.com/categories/mysql/"},{"title":"tools","uri":"https://blog.fengjx.com/categories/tools/"},{"title":"zookeeper","uri":"https://blog.fengjx.com/categories/zookeeper/"},{"title":"其他","uri":"https://blog.fengjx.com/categories/%E5%85%B6%E4%BB%96/"},{"title":"微服务","uri":"https://blog.fengjx.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"posts":[{"content":"curl参数详解 Common Options -#, --progress-bar Make curl display a simple progress bar instead of the more informational standard meter.\n-b, --cookie \u0026lt;name=data\u0026gt; Supply cookie with request. If no =, then specifies the cookie file to use (see -c).\n-c, --cookie-jar \u0026lt;file name\u0026gt; File to save response cookies to.\n-d, --data \u0026lt;data\u0026gt; Send specified data in POST request. Details provided below.\n-f, --fail Fail silently (don\u0026rsquo;t output HTML error form if returned).\n-F, --form \u0026lt;name=content\u0026gt; Submit form data.\n-H, --header \u0026lt;header\u0026gt; Headers to supply with request.\n-i, --include Include HTTP headers in the output.\n-I, --head Fetch headers only.\n-k, --insecure Allow insecure connections to succeed.\n-L, --location Follow redirects.\n-o, --output \u0026lt;file\u0026gt; Write output to . Can use --create-dirs in conjunction with this to create any directories specified in the -o path.\n-O, --remote-name Write output to file named like the remote file (only writes to current directory).\n-s, --silent Silent (quiet) mode. Use with -S to force it to show errors.\n-v, --verbose Provide more information (useful for debugging).\n-w, --write-out \u0026lt;format\u0026gt; Make curl display information on stdout after a completed transfer. See man page for more details on available variables. Convenient way to force curl to append a newline to output: -w \u0026quot;\\n\u0026quot; (can add to ~/.curlrc).\n-X, --request The request method to use.\nPOST When sending data via a POST or PUT request, two common formats (specified via the Content-Type header) are:\n application/json application/x-www-form-urlencoded  Many APIs will accept both formats, so if you\u0026rsquo;re using curl at the command line, it can be a bit easier to use the form urlencoded format instead of json because\n the json format requires a bunch of extra quoting curl will send form urlencoded by default, so for json the Content-Type header must be explicitly set  This gist provides examples for using both formats, including how to use sample data files in either format with your curl requests.\ncurl usage For sending data with POST and PUT requests, these are common curl options:\n  request type\n -X POST -X PUT    content type header\n  -H \u0026quot;Content-Type: application/x-www-form-urlencoded\u0026quot;\n  -H \u0026quot;Content-Type: application/json\u0026quot;\n  data\n form urlencoded: -d \u0026quot;param1=value1\u0026amp;param2=value2\u0026quot; or -d @data.txt json: -d '{\u0026quot;key1\u0026quot;:\u0026quot;value1\u0026quot;, \u0026quot;key2\u0026quot;:\u0026quot;value2\u0026quot;}' or -d @data.json    Examples POST application/x-www-form-urlencoded application/x-www-form-urlencoded is the default:\ncurl -d \u0026quot;param1=value1\u0026amp;param2=value2\u0026quot; -X POST http://localhost:3000/data  explicit:\ncurl -d \u0026quot;param1=value1\u0026amp;param2=value2\u0026quot; -H \u0026quot;Content-Type: application/x-www-form-urlencoded\u0026quot; -X POST http://localhost:3000/data  with a data file\ncurl -d \u0026quot;@data.txt\u0026quot; -X POST http://localhost:3000/data  POST application/json curl -d '{\u0026quot;key1\u0026quot;:\u0026quot;value1\u0026quot;, \u0026quot;key2\u0026quot;:\u0026quot;value2\u0026quot;}' -H \u0026quot;Content-Type: application/json\u0026quot; -X POST http://localhost:3000/data  with a data file\ncurl -d \u0026quot;@data.json\u0026quot; -X POST http://localhost:3000/data ","id":0,"section":"posts","summary":"curl参数详解 Common Options -#, --progress-bar Make curl display a simple progress bar instead of the more informational standard meter. -b, --cookie \u0026lt;name=data\u0026gt; Supply cookie with request. If no =, then specifies the cookie file to use (see -c). -c, --cookie-jar \u0026lt;file name\u0026gt; File to save response cookies to. -d, --data \u0026lt;data\u0026gt; Send specified data in POST request. Details provided below. -f, --fail Fail","tags":["curl"],"title":"curl参数详解","uri":"https://blog.fengjx.com/curl/","year":"2019"},{"content":"npm -\u0026gt; yarn命令对照    npm(v5) yarn 说明     npm install yarn install -   (N/A) yarn install \u0026ndash;flat -   (N/A) yarn install \u0026ndash;har -   npm install \u0026ndash;no-package-lock yarn install \u0026ndash;no-lockfile -   (N/A) yarn install \u0026ndash;pure-lockfile -   npm install [package] \u0026ndash;save yarn add [package] -   npm install [package] \u0026ndash;save-dev yarn add [package] \u0026ndash;dev -   (N/A) yarn add [package] \u0026ndash;peer -   npm install [package] \u0026ndash;save-optional yarn add [package] \u0026ndash;optional -   npm install [package] \u0026ndash;save-exact yarn add [package] \u0026ndash;exact -   (N/A) - yarn add [package] \u0026ndash;tilde -    npm install [package] \u0026ndash;global yarn global add [package] -   npm update \u0026ndash;global yarn global upgrade -   npm rebuild yarn add \u0026ndash;force -   npm uninstall [package] yarn remove [package] -   npm cache clean yarn cache clean [package] -   rm -rf node_modules \u0026amp;\u0026amp; npm install yarn upgrade -   npm version major yarn version \u0026ndash;major -   npm version minor yarn version \u0026ndash;minor -   npm version patch yarn version \u0026ndash;patch -    ","id":1,"section":"posts","summary":"npm -\u0026gt; yarn命令对照 npm(v5) yarn 说明 npm install yarn install - (N/A) yarn install \u0026ndash;flat - (N/A) yarn install \u0026ndash;har - npm install \u0026ndash;no-package-lock yarn install \u0026ndash;no-lockfile - (N/A) yarn install \u0026ndash;pure-lockfile - npm install [package] \u0026ndash;save yarn add [package] - npm install [package] \u0026ndash;save-dev yarn add [package] \u0026ndash;dev - (N/A) yarn add [package] \u0026ndash;peer - npm install [package] \u0026ndash;save-optional yarn add","tags":["npm","yarn"],"title":"npm -\u003e yarn命令对照","uri":"https://blog.fengjx.com/npm-yarn/","year":"2019"},{"content":"","id":2,"section":"posts","summary":"","tags":["index"],"title":"Posts","uri":"https://blog.fengjx.com/posts/","year":"2019"},{"content":"install # 安装 sudo pacman -S docker # 启动docker sudo systemctl start docker # 查看状态 sudo systemctl status docker # 设置开启启动 sudo systemctl enable docker ","id":3,"section":"posts","summary":"install # 安装 sudo pacman -S docker # 启动docker sudo systemctl start docker # 查看状态 sudo systemctl status docker # 设置开启启动 sudo systemctl enable docker","tags":["manjaro","docker"],"title":"manjaro安装docker","uri":"https://blog.fengjx.com/manjaro-install-docker/","year":"2019"},{"content":"# 安装 ➜ ~ sudo pacman -S mysql # 初始化MySQL # root@localhost: fip6sD,Et)_\u0026amp;，会输出root初始密码 ➜ ~ sudo mysqld --initialize --user=mysql --basedir=/usr --datadir=/var/lib/mysql 2019-10-28T17:26:22.653266Z 0 [Warning] [MY-010915] [Server] \u0026#39;NO_ZERO_DATE\u0026#39;, \u0026#39;NO_ZERO_IN_DATE\u0026#39; and \u0026#39;ERROR_FOR_DIVISION_BY_ZERO\u0026#39; sql modes should be used with strict mode. They will be merged with strict mode in a future release. 2019-10-28T17:26:22.653314Z 0 [System] [MY-013169] [Server] /usr/bin/mysqld (mysqld 8.0.17) initializing of server in progress as process 8610 2019-10-28T17:26:25.513724Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: fip6sD,Et)_\u0026amp; 2019-10-28T17:26:27.125793Z 0 [System] [MY-013170] [Server] /usr/bin/mysqld (mysqld 8.0.17) initializing of server has completed # 设置开启 ➜ ~ sudo systemctl enable mysqld.service ➜ ~ sudo systemctl daemon-reload # 启动MySQL ➜ ~ sudo systemctl start mysqld.service # 初始化安全设置，按照提示一步步设置就好 ~ mysql_secure_installation Securing the MySQL server deployment. Enter password for user root: The existing password for the user account root has expired. Please set a new password. New password: #设置新的密码 Re-enter new password: VALIDATE PASSWORD COMPONENT can be used to test passwords and improve security. It checks the strength of password and allows the users to set only those passwords which are secure enough. Would you like to setup VALIDATE PASSWORD component? Press y|Y for Yes, any other key for No: y There are three levels of password validation policy: LOW Length \u0026gt;= 8 MEDIUM Length \u0026gt;= 8, numeric, mixed case, and special characters STRONG Length \u0026gt;= 8, numeric, mixed case, special characters and dictionary file Please enter 0 = LOW, 1 = MEDIUM and 2 = STRONG: 0 # 设置密码安全级别 Using existing password for root. Estimated strength of the password: 100 Change the password for root ? ((Press y|Y for Yes, any other key for No) : ... skipping. By default, a MySQL installation has an anonymous user, allowing anyone to log into MySQL without having to have a user account created for them. This is intended only for testing, and to make the installation go a bit smoother. You should remove them before moving into a production environment. Remove anonymous users? (Press y|Y for Yes, any other key for No) : y # 是否删除匿名用户 Success. Normally, root should only be allowed to connect from \u0026#39;localhost\u0026#39;. This ensures that someone cannot guess at the root password from the network. Disallow root login remotely? (Press y|Y for Yes, any other key for No) : # 是否禁止root用户远程访问 ... skipping. By default, MySQL comes with a database named \u0026#39;test\u0026#39; that anyone can access. This is also intended only for testing, and should be removed before moving into a production environment. Remove test database and access to it? (Press y|Y for Yes, any other key for No) : y # 是否删除测试库 - Dropping test database... Success. - Removing privileges on test database... Success. Reloading the privilege tables will ensure that all changes made so far will take effect immediately. Reload privilege tables now? (Press y|Y for Yes, any other key for No) : y # 是否刷新数据库授权 Success. All done! ","id":4,"section":"posts","summary":"# 安装 ➜ ~ sudo pacman -S mysql # 初始化MySQL # root@localhost: fip6sD,Et)_\u0026amp;，会输出root初始密码 ➜ ~ sudo mysqld --initialize --user=mysql --basedir=/usr --datadir=/var/lib/mysql 2019-10-28T17:26:22.653266Z 0 [Warning] [MY-010915] [Server] \u0026#39;NO_ZERO_DATE\u0026#39;, \u0026#39;NO_ZERO_IN_DATE\u0026#39; and \u0026#39;ERROR_FOR_DIVISION_BY_ZERO\u0026#39; sql modes should be used","tags":["manjaro","mysql"],"title":"manjaro安装MySQL","uri":"https://blog.fengjx.com/manjaro-install-mysql/","year":"2019"},{"content":"Mac 键盘快捷键 按键符号对照  Command（或 Cmd）⌘ Shift ⇧ Option（或 Alt）⌥ Control（或 Ctrl）⌃ Caps Lock ⇪  剪切、拷贝、粘贴和其他常用快捷键  Command-X：剪切所选项并拷贝到剪贴板。 Command-C：将所选项拷贝到剪贴板。这同样适用于“访达”中的文件。 Command-V：将剪贴板的内容粘贴到当前文稿或应用中。这同样适用于“访达”中的文件。 Command-Z：撤销上一个命令。随后您可以按 Shift-Command-Z 来重做，从而反向执行撤销命令。在某些应用中，您可以撤销和重做多个命令。 Command-A：全选各项。 Command-F：查找文稿中的项目或打开“查找”窗口。 Command-G：再次查找：查找之前所找到项目出现的下一个位置。要查找出现的上一个位置，请按 Shift-Command-G。 Command-H：隐藏最前面的应用的窗口。要查看最前面的应用但隐藏所有其他应用，请按 Option-Command-H。 Command-M：将最前面的窗口最小化至“程序坞”。要最小化最前面的应用的所有窗口，请按 Option-Command-M。 Command-O：打开所选项，或打开一个对话框以选择要打开的文件。 Command-P：打印当前文稿。 Command-S：存储当前文稿。 Command-T：打开新标签页。 Command-W：关闭最前面的窗口。要关闭应用的所有窗口，请按下 Option-Command-W。 Option-Command-Esc：强制退出应用。 Command–空格键：显示或隐藏“聚焦”搜索栏。要从“访达”窗口执行“聚焦”搜索，请按 Command–Option–空格键。（如果您使用多个输入源以便用不同的语言键入内容，这些快捷键会更改输入源而非显示“聚焦”。了解如何更改冲突的键盘快捷键。） Control-Command–空格键：显示字符检视器，您可以从中选择表情符号和其他符号。 Control-Command-F：全屏使用应用（如果应用支持）。 空格键：使用快速查看来预览所选项。 Command-Tab：在打开的应用中切换到下一个最近使用的应用。 Shift-Command-5：在 macOS Mojave 中，拍摄屏幕快照或录制屏幕。在更早的 macOS 版本中，请使用 Shift-Command-3 或 Shift-Command-4 来拍摄屏幕快照。进一步了解屏幕快照。 Shift-Command-N：在“访达”中创建一个新文件夹。 Command-逗号 (,)：打开最前面的应用的偏好设置。  访达和系统快捷键  Command-D：复制所选文件。 Command-E：推出所选磁盘或宗卷。 Command-F：在“访达”窗口中开始“聚焦”搜索。 Command-I：显示所选文件的“显示简介”窗口。 Command-R：(1) 如果在“访达”中选择了某个别名：显示所选别名对应的原始文件。(2) 在某些应用（如“日历”或 Safari 浏览器）中，刷新或重新载入页面。(3) 在“软件更新”偏好设置中，再次检查有没有软件更新。 Shift-Command-C：打开“电脑”窗口。 Shift-Command-D：打开“桌面”文件夹。 Shift-Command-F：打开“最近使用”窗口，其中显示了您最近查看或更改过的所有文件。 Shift-Command-G：打开“前往文件夹”窗口。 Shift-Command-H：打开当前 macOS 用户帐户的个人文件夹。 Shift-Command-I：打开 iCloud 云盘。 Shift-Command-K：打开“网络”窗口。 Option-Command-L：打开“下载”文件夹。 Shift-Command-N：新建文件夹。 Shift-Command-O：打开“文稿”文件夹。 Shift-Command-P：在“访达”窗口中显示或隐藏预览面板。 Shift-Command-R：打开“隔空投送”窗口。 Shift-Command-T：显示或隐藏“访达”窗口中的标签页栏。 Ctrl-Shift-Command-T：将所选的“访达”项目添加到“程序坞”（OS X Mavericks 或更高版本） Shift-Command-U：打开“实用工具”文件夹。 Option-Command-D：显示或隐藏“程序坞”。 Control-Command-T：将所选项添加到边栏（OS X Mavericks 或更高版本）。 Option-Command-P：隐藏或显示“访达”窗口中的路径栏。 Option-Command-S：隐藏或显示“访达”窗口中的边栏。 Command–斜线 (/)：隐藏或显示“访达”窗口中的状态栏。 Command-J：显示“显示”选项。 Command-K：打开“连接服务器”窗口。 Command-L：为所选项制作替身。 Command-N：打开一个新的“访达”窗口。 Option-Command-N：新建智能文件夹。 Command-T：在当前“访达”窗口中有单个标签页开着的状态下显示或隐藏标签页栏。 Option-Command-T：在当前“访达”窗口中有单个标签页开着的状态下显示或隐藏工具栏。 Option-Command-V：移动：将剪贴板中的文件从原始位置移动到当前位置。 Command-Y：使用“快速查看”预览所选文件。 Option-Command-Y：显示所选文件的快速查看幻灯片显示。 Command-1：以图标方式显示“访达”窗口中的项目。 Command-2：以列表方式显示“访达”窗口中的项目。 Command-3：以分栏方式显示“访达”窗口中的项目。 Command-4：以封面流方式显示“访达”窗口中的项目。 Command–左中括号 ([)：前往上一文件夹。 Command–右中括号 (])：前往下一个文件夹。 Command–上箭头：打开包含当前文件夹的文件夹。 Command–Control–上箭头：在新窗口中打开包含当前文件夹的文件夹。 Command–下箭头：打开所选项。 右箭头：打开所选文件夹。这个快捷键仅在列表视图中有效。 左箭头：关闭所选文件夹。这个快捷键仅在列表视图中有效。 Command-Delete：将所选项移到废纸篓。 Shift-Command-Delete：清倒废纸篓。 Option-Shift-Command-Delete：清倒废纸篓而不显示确认对话框。 Command–调高亮度：打开或关闭目标显示器模式。 Command–调低亮度：当您的 Mac 连接到多台显示器时，打开或关闭视频镜像。 Option–调高亮度：打开“显示器”偏好设置。这个快捷键可与任一亮度键搭配使用。 Control–调高亮度或 Control–调低亮度：更改外部显示器的亮度（如果显示器支持）。 Option-Shift–调高亮度或 Option-Shift–调低亮度：以较小的步幅调节显示器亮度。如果您的显示器支持，可以将 Control 键添加到此快捷键，以便在外置显示器上进行调节。 Option–“调度中心”：打开“调度中心”偏好设置。 Command–“调度中心”：显示桌面。 Control–下箭头：显示最前面的应用的所有窗口。 Option–调高音量：打开“声音”偏好设置。这个快捷键可与任一音量键搭配使用。 Option-Shift–调高音量或 Option-Shift–调低音量：以较小的步幅调节音量。 Option–键盘调高亮度：打开“键盘”偏好设置。这个快捷键可与任一键盘亮度键搭配使用。 Option-Shift–键盘调高亮度或 Option-Shift–键盘调低亮度：以较小的步幅调节键盘亮度。 连按 Option 键：在单独的窗口中打开项目，然后关闭原始窗口。 连按 Command 键：在单独的标签页或窗口中打开文件夹。 按住 Command 键拖移到另一个宗卷：将拖移的项目移到另一个宗卷，而不是拷贝它。 按住 Option 键拖移：拷贝托移的项目。拖移项目时指针会随之变化。 按住 Option-Command 键拖移：为拖移的项目制作替身。拖移项目时指针会随之变化。 按住 Option 键点按开合三角：打开所选文件夹内的所有文件夹。此快捷键仅在列表视图中有效。 按住 Command 键点按窗口标题：查看包含当前文件夹的文件夹。 了解如何使用 Command 或 Shift 在“访达”中选择多个项目。 点按“访达”菜单栏中的“前往”菜单查看用于打开许多常用文件夹（如“应用程序”、“文稿”、“下载”、“实用工具”和“iCloud 云盘”）的快捷键。  文稿快捷键  Command-B：以粗体显示所选文本，或者打开或关闭粗体显示功能。 Command-I：以斜体显示所选文本，或者打开或关闭斜体显示功能。 Command-K：添加网页链接。 Command-U：对所选文本加下划线，或者打开或关闭加下划线功能。 Command-T：显示或隐藏“字体”窗口。 Command-D：从“打开”对话框或“存储”对话框内选择“桌面”文件夹。 Control-Command-D：显示或隐藏所选字词的定义。 Shift-Command–冒号 (:)：显示“拼写和语法”窗口。 Command–分号 (;)：查找文稿中拼写错误的字词。 Option-Delete：删除插入点左边的字词。 Control-H：删除插入点左边的字符。也可以使用 Delete 键。 Control-D：删除插入点右边的字符。也可以使用 Fn-Delete。 Fn-Delete：在没有向前删除 键的键盘上向前删除。也可以使用 Control-D。 Control-K：删除插入点与行或段落末尾处之间的文本。 Fn–上箭头：Page Up：向上滚动一页。 Fn–下箭头：Page Down：向下滚动一页。 Fn–左箭头：Home：滚动到文稿开头。 Fn–右箭头：End：滚动到文稿末尾。 Command–上箭头：将插入点移至文稿开头。 Command–下箭头：将插入点移至文稿末尾。 Command–左箭头：将插入点移至当前行的行首。 Command–右箭头：将插入点移至当前行的行尾。 Option–左箭头：将插入点移至上一字词的词首。 Option–右箭头：将插入点移至下一字词的词尾。 Shift-Command–上箭头：选中插入点与文稿开头之间的文本。 Shift-Command–下箭头：选中插入点与文稿末尾之间的文本。 Shift-Command–左箭头：选中插入点与当前行行首之间的文本。 Shift-Command–右箭头：选中插入点与当前行行尾之间的文本。 Shift–上箭头：将文本选择范围扩展到上一行相同水平位置的最近字符处。 Shift–下箭头：将文本选择范围扩展到下一行相同水平位置的最近字符处。 Shift–左箭头：将文本选择范围向左扩展一个字符。 Shift–右箭头：将文本选择范围向右扩展一个字符。 Option–Shift–上箭头：将文本选择范围扩展到当前段落的段首，再按一次则扩展到下一段落的段首。 Option–Shift–下箭头：将文本选择范围扩展到当前段落的段尾，再按一次则扩展到下一段落的段尾。 Option–Shift–左箭头：将文本选择范围扩展到当前字词的词首，再按一次则扩展到后一字词的词首。 Option–Shift–左箭头：将文本选择范围扩展到当前字词的词尾，再按一次则扩展到后一字词的词尾。 Control–A：移至行或段落的开头。 Control–E：移至行或段落的末尾。 Control–F：向前移动一个字符。 Control–B：向后移动一个字符。 Control–L：将光标或所选内容置于可见区域中央。 Control–P：上移一行。 Control–N：下移一行。 Control–O：在插入点后新插入一行。 Control–T：将插入点后面的字符与插入点前面的字符交换。 Command–左花括号 ({)：左对齐。 Command–右花括号 (})：右对齐。 Shift-Command–竖线 (|)：居中对齐。 Option-Command-F：前往搜索栏。 Option-Command-T：显示或隐藏应用中的工具栏。 Option-Command-C：拷贝样式：将所选项的格式设置拷贝到剪贴板。 Option-Command-V：粘贴样式：将拷贝的样式应用到所选项。 Option-Shift-Command-V：粘贴并匹配样式：将周围内容的样式应用到粘贴在该内容中的项目。 Option-Command-I：显示或隐藏检查器窗口。 Shift-Command-P：页面设置：显示用于选择文稿设置的窗口。 Shift-Command-S：显示“存储为”对话框或复制当前文稿。 Shift-Command-减号 (-)：缩小所选项。 Shift-Command-加号 (+)：放大所选项。Command–等号 (=) 可实现相同的功能。 Shift-Command–问号 (?)：打开“帮助”菜单。  原文\nhttps://support.apple.com/zh-cn/HT201236\n","id":5,"section":"posts","summary":"Mac 键盘快捷键 按键符号对照 Command（或 Cmd）⌘ Shift ⇧ Option（或 Alt）⌥ Control（或 Ctrl）⌃ Caps Lock ⇪ 剪切、拷贝、粘贴和其他","tags":["mac"],"title":"Mac 键盘快捷键","uri":"https://blog.fengjx.com/mac-keymap/","year":"2019"},{"content":"ffmpeg下载m3u8直播流 ffmpeg -i http://www.abc.com/aaa.m3u8 \u0026quot;filename.mp4\u0026quot; ","id":6,"section":"posts","summary":"ffmpeg下载m3u8直播流 ffmpeg -i http://www.abc.com/aaa.m3u8 \u0026quot;filename.mp4\u0026quot;","tags":["ffmpeg"],"title":"ffmpeg下载m3u8直播流","uri":"https://blog.fengjx.com/ffmpeg-download-m3u8/","year":"2018"},{"content":"ffmpeg合并视频文件，对于 MPEG 格式的视频，可以直接连接：\nffmpeg -i \u0026quot;concat:input1.mpg|input2.mpg|input3.mpg\u0026quot; -c copy output.mpg 对于非 MPEG 格式容器，但是是 MPEG 编码器（H.264、DivX、XviD、MPEG4、MPEG2、AAC、MP2、MP3 等），可以包装进 TS 格式的容器再合并。在新浪视频，有很多视频使用 H.264 编码器，可以采用这个方法\nffmpeg -i input1.flv -c copy -bsf:v h264_mp4toannexb -f mpegts input1.ts ffmpeg -i input2.flv -c copy -bsf:v h264_mp4toannexb -f mpegts input2.ts ffmpeg -i input3.flv -c copy -bsf:v h264_mp4toannexb -f mpegts input3.ts ffmpeg -i \u0026quot;concat:input1.ts|input2.ts|input3.ts\u0026quot; -c copy -bsf:a aac_adtstoasc -movflags +faststart output.mp4 ","id":7,"section":"posts","summary":"ffmpeg合并视频文件，对于 MPEG 格式的视频，可以直接连接： ffmpeg -i \u0026quot;concat:input1.mpg|input2.mpg|input3.mpg\u0026quot; -c copy output.mpg 对于非 MPEG 格式容器，但是是 MPEG 编码器（H.264、DivX、XviD、MP","tags":["ffmpeg"],"title":"ffmpeg合并视频文件","uri":"https://blog.fengjx.com/ffmpeg-merge-video/","year":"2018"},{"content":"mac下使用supervisor  安装 使用brew进行 安装  $ brew install supervisor ==\u0026gt; Downloading http://7xkcej.dl1.z0.glb.clouddn.com/bottles/supervisor-3.3.1.sierra.bottle.tar.gz ######################################################################## 100.0% ==\u0026gt; Pouring supervisor-3.3.1.sierra.bottle.tar.gz ==\u0026gt; Using the sandbox ==\u0026gt; Caveats To have launchd start supervisor now and restart at login: brew services start supervisor Or, if you don\u0026#39;t want/need a background service you can just run: supervisord -c /usr/local/etc/supervisord.ini ==\u0026gt; Summary 🍺 /usr/local/Cellar/supervisor/3.3.1: 526 files, 6.3MB fengjianxindeMacBook-Pro:worlspaces fengjianxin$ cd /etc/s security/ services shells snmp/ ssh/ ssl/ sudo_lecture sudoers sudoers.d/ syslog.conf fengjianxindeMacBook-Pro:worlspaces fengjianxin$ vi /usr/local/etc/supervisord.ini fengjianxindeMacBook-Pro:worlspaces fengjianxin$ fengjianxindeMacBook-Pro:worlspaces fengjianxin$ fengjianxindeMacBook-Pro:worlspaces fengjianxin$ fengjianxindeMacBook-Pro:worlspaces fengjianxin$ brew services start supervisor ==\u0026gt; Tapping homebrew/services Cloning into \u0026#39;/usr/local/Homebrew/Library/Taps/homebrew/homebrew-services\u0026#39;... remote: Counting objects: 10, done. remote: Compressing objects: 100% (7/7), done. remote: Total 10 (delta 0), reused 6 (delta 0), pack-reused 0 Unpacking objects: 100% (10/10), done. Tapped 0 formulae (37 files, 51KB) ==\u0026gt; Successfully started `supervisor` (label: homebrew.mxcl.supervisor) vi /Library/LaunchDaemons/homebrew.mxcl.supervisor.plist 可以看到，安装的时候已经默认添加了开机启动（root）\n开启web管理  vi /usr/local/etc/supervisord.ini # 将下面注释去掉 [inet_http_server] ; inet (TCP) server disabled by default port=127.0.0.1:9001 ; (ip_address:port specifier, *:port for all iface) username=fengjx ; (default is no username (open server)) password=fengjx1989 ; (default is no password (open server)) # 重启服务 $ brew services start supervisor ==\u0026gt; Tapping homebrew/services Cloning into \u0026#39;/usr/local/Homebrew/Library/Taps/homebrew/homebrew-services\u0026#39;... remote: Counting objects: 10, done. remote: Compressing objects: 100% (7/7), done. remote: Total 10 (delta 0), reused 6 (delta 0), pack-reused 0 Unpacking objects: 100% (10/10), done. Tapped 0 formulae (37 files, 51KB) ==\u0026gt; Successfully started `supervisor` (label: homebrew.mxcl.supervisor) 打开浏览器输入：http://127.0.0.1:9001/，可以看到管理界面了\n管理进程 supervisord.ini的最后一行配置  [include] files = /usr/local/etc/supervisor.d/*.ini 说明我们可以吧配置文件写到/usr/local/etc/supervisor.d/目录下，只要以.ini后缀结尾就行\neg. 管理nginx，前提是nginx已经安装好\nvi nginx.ini [program:nginx] command = sudo /usr/local/bin/nginx stdout_logfile=/data/home/supervisor/logs/nginx_stdout.log stdout_logfile_maxbytes=10MB stderr_logfile=/data/home/supervisor/logs/nginx_stderr.log stderr_logfile_maxbytes=10MB autostart=true autorestart=true ;environment = PATH=\u0026quot;$PATH:/usr/local/bin\u0026quot; 使用supervisorctl启动nginx\nsupervisorctl start nginx 或者在web管理界面中点击start 附 supervisord.ini详解  [unix_http_server]  file=/tmp/supervisor.sock ; socket文件的路径，supervisorctl用XML_RPC和supervisord通信就是通过它进行 的。如果不设置的话，supervisorctl也就不能用了 不设置的话，默认为none。 非必须设置  ;chmod=0700 ; 这个简单，就是修改上面的那个socket文件的权限为0700 不设置的话，默认为0700。 非必须设置 ;chown=nobody:nogroup ; 这个一样，修改上面的那个socket文件的属组为user.group 不设置的话，默认为启动supervisord进程的用户及属组。非必须设置 ;username=user ; 使用supervisorctl连接的时候，认证的用户 不设置的话，默认为不需要用户。 非必须设置 ;password=123 ; 和上面的用户名对应的密码，可以直接使用明码，也可以使用SHA加密 如：{SHA}82ab876d1387bfafe46cc1c8a2ef074eae50cb1d 默认不设置。。。非必须设置 ;[inet_http_server] ; 侦听在TCP上的socket，Web Server和远程的supervisorctl都要用到他 不设置的话，默认为不开启。非必须设置 ;port=127.0.0.1:9001 ; 这个是侦听的IP和端口，侦听所有IP用 :9001或*:9001。 这个必须设置，只要上面的[inet_http_server]开启了，就必须设置它 ;username=user ; 这个和上面的uinx_http_server一个样。非必须设置 ;password=123 ; 这个也一个样。非必须设置 [supervisord] ;这个主要是定义supervisord这个服务端进程的一些参数的 这个必须设置，不设置，supervisor就不用干活了 logfile=/tmp/supervisord.log ; 这个是supervisord这个主进程的日志路径，注意和子进程的日志不搭嘎。 默认路径$CWD/supervisord.log，$CWD是当前目录。。非必须设置 logfile_maxbytes=50MB ; 这个是上面那个日志文件的最大的大小，当超过50M的时候，会生成一个新的日 志文件。当设置为0时，表示不限制文件大小 默认值是50M，非必须设置。  logfile_backups=10 ; 日志文件保持的数量，上面的日志文件大于50M时，就会生成一个新文件。文件 数量大于10时，最初的老文件被新文件覆盖，文件数量将保持为10 当设置为0时，表示不限制文件的数量。 默认情况下为10。。。非必须设置 loglevel=info ; 日志级别，有critical, error, warn, info, debug, trace, or blather等 默认为info。。。非必须设置项 pidfile=/tmp/supervisord.pid ; supervisord的pid文件路径。 默认为$CWD/supervisord.pid。。。非必须设置 nodaemon=false ; 如果是true，supervisord进程将在前台运行 默认为false，也就是后台以守护进程运行。。。非必须设置 minfds=1024 ; 这个是最少系统空闲的文件描述符，低于这个值supervisor将不会启动。 系统的文件描述符在这里设置cat /proc/sys/fs/file-max 默认情况下为1024。。。非必须设置 minprocs=200 ; 最小可用的进程描述符，低于这个值supervisor也将不会正常启动。 ulimit -u这个命令，可以查看linux下面用户的最大进程数 默认为200。。。非必须设置 ;umask=022 ; 进程创建文件的掩码 默认为022。。非必须设置项 ;user=chrism ; 这个参数可以设置一个非root用户，当我们以root用户启动supervisord之后。 我这里面设置的这个用户，也可以对supervisord进行管理 默认情况是不设置。。。非必须设置项 ;identifier=supervisor ; 这个参数是supervisord的标识符，主要是给XML_RPC用的。当你有多个 supervisor的时候，而且想调用XML_RPC统一管理，就需要为每个 supervisor设置不同的标识符了 默认是supervisord。。。非必需设置 ;directory=/tmp ; 这个参数是当supervisord作为守护进程运行的时候，设置这个参数的话，启动 supervisord进程之前，会先切换到这个目录 默认不设置。。。非必须设置 ;nocleanup=true ; 这个参数当为false的时候，会在supervisord进程启动的时候，把以前子进程 产生的日志文件(路径为AUTO的情况下)清除掉。有时候咱们想要看历史日志，当  然不想日志被清除了。所以可以设置为true 默认是false，有调试需求的同学可以设置为true。。。非必须设置 ;childlogdir=/tmp ; 当子进程日志路径为AUTO的时候，子进程日志文件的存放路径。 默认路径是这个东西，执行下面的这个命令看看就OK了，处理的东西就默认路径 python -c \u0026#34;import tempfile;print tempfile.gettempdir()\u0026#34; 非必须设置 ;environment=KEY=\u0026#34;value\u0026#34; ; 这个是用来设置环境变量的，supervisord在linux中启动默认继承了linux的 环境变量，在这里可以设置supervisord进程特有的其他环境变量。 supervisord启动子进程时，子进程会拷贝父进程的内存空间内容。 所以设置的 这些环境变量也会被子进程继承。 小例子：environment=name=\u0026#34;haha\u0026#34;,age=\u0026#34;hehe\u0026#34; 默认为不设置。。。非必须设置 ;strip_ansi=false ; 这个选项如果设置为true，会清除子进程日志中的所有ANSI 序列。什么是ANSI 序列呢？就是我们的\\n,\\t这些东西。 默认为false。。。非必须设置 ; the below section must remain in the config file for RPC ; (supervisorctl/web interface) to work, additional interfaces may be ; added by defining them in separate rpcinterface: sections [rpcinterface:supervisor] ;这个选项是给XML_RPC用的，当然你如果想使用supervisord或者web server 这  个选项必须要开启的 supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface  [supervisorctl] ;这个主要是针对supervisorctl的一些配置  serverurl=unix:///tmp/supervisor.sock ; 这个是supervisorctl本地连接supervisord的时候，本地UNIX socket 路径，注意这个是和前面的[unix_http_server]对应的 默认值就是unix:///tmp/supervisor.sock。。非必须设置 ;serverurl=http://127.0.0.1:9001 ; 这个是supervisorctl远程连接supervisord的时候，用到的TCP socket路径 注意这个和前面的[inet_http_server]对应 默认就是http://127.0.0.1:9001。。。非必须项 ;username=chris ; 用户名 默认空。。非必须设置 ;password=123 ; 密码 默认空。。非必须设置 ;prompt=mysupervisor ; 输入用户名密码时候的提示符 默认supervisor。。非必须设置 ;history_file=~/.sc_history ; 这个参数和shell中的history类似，我们可以用上下键来查找前面执行过的命令 默认是no file的。。所以我们想要有这种功能，必须指定一个文件。。。非 必须设置 ; The below sample program section shows all possible program subsection values, ; create one or more \u0026#39;real\u0026#39; program: sections to be able to control them under ; supervisor. ;[program:theprogramname] ;这个就是咱们要管理的子进程了，\u0026#34;:\u0026#34;后面的是名字，最好别乱写和实际进程 有点关联最好。这样的program我们可以设置一个或多个，一个program就是 要被管理的一个进程 ;command=/bin/cat ; 这个就是我们的要启动进程的命令路径了，可以带参数 例子：/home/test.py -a \u0026#39;hehe\u0026#39; 有一点需要注意的是，我们的command只能是那种在终端运行的进程，不能是 守护进程。这个想想也知道了，比如说command=service httpd start。 httpd这个进程被linux的service管理了，我们的supervisor再去启动这个命令 这已经不是严格意义的子进程了。 这个是个必须设置的项 ;process_name=%(program_name)s ; 这个是进程名，如果我们下面的numprocs参数为1的话，就不用管这个参数 了，它默认值%(program_name)s也就是上面的那个program冒号后面的名字， 但是如果numprocs为多个的话，那就不能这么干了。想想也知道，不可能每个 进程都用同一个进程名吧。 ;numprocs=1 ; 启动进程的数目。当不为1时，就是进程池的概念，注意process_name的设置 默认为1 。。非必须设置 ;directory=/tmp ; 进程运行前，会前切换到这个目录 默认不设置。。。非必须设置 ;umask=022 ; 进程掩码，默认none，非必须 ;priority=999 ; 子进程启动关闭优先级，优先级低的，最先启动，关闭的时候最后关闭 默认值为999 。。非必须设置 ;autostart=true ; 如果是true的话，子进程将在supervisord启动后被自动启动 默认就是true 。。非必须设置 ;autorestart=unexpected ; 这个是设置子进程挂掉后自动重启的情况，有三个选项，false,unexpected 和true。如果为false的时候，无论什么情况下，都不会被重新启动， 如果为unexpected，只有当进程的退出码不在下面的exitcodes里面定义的退  出码的时候，才会被自动重启。当为true的时候，只要子进程挂掉，将会被无 条件的重启 ;startsecs=1 ; 这个选项是子进程启动多少秒之后，此时状态如果是running，则我们认为启 动成功了 默认值为1 。。非必须设置 ;startretries=3 ; 当进程启动失败后，最大尝试启动的次数。。当超过3次后，supervisor将把 此进程的状态置为FAIL 默认值为3 。。非必须设置 ;exitcodes=0,2 ; 注意和上面的的autorestart=unexpected对应。。exitcodes里面的定义的 退出码是expected的。 ;stopsignal=QUIT ; 进程停止信号，可以为TERM, HUP, INT, QUIT, KILL, USR1, or USR2等信号 默认为TERM 。。当用设定的信号去干掉进程，退出码会被认为是expected 非必须设置 ;stopwaitsecs=10 ; 这个是当我们向子进程发送stopsignal信号后，到系统返回信息 给supervisord，所等待的最大时间。 超过这个时间，supervisord会向该 子进程发送一个强制kill的信号。 默认为10秒。。非必须设置 ;stopasgroup=false ; 这个东西主要用于，supervisord管理的子进程，这个子进程本身还有 子进程。那么我们如果仅仅干掉supervisord的子进程的话，子进程的子进程 有可能会变成孤儿进程。所以咱们可以设置可个选项，把整个该子进程的 整个进程组都干掉。 设置为true的话，一般killasgroup也会被设置为true。 需要注意的是，该选项发送的是stop信号 默认为false。。非必须设置。。 ;killasgroup=false ; 这个和上面的stopasgroup类似，不过发送的是kill信号 ;user=chrism ; 如果supervisord是root启动，我们在这里设置这个非root用户，可以用来 管理该program 默认不设置。。。非必须设置项 ;redirect_stderr=true ; 如果为true，则stderr的日志会被写入stdout日志文件中 默认为false，非必须设置 ;stdout_logfile=/a/path ; 子进程的stdout的日志路径，可以指定路径，AUTO，none等三个选项。 设置为none的话，将没有日志产生。设置为AUTO的话，将随机找一个地方 生成日志文件，而且当supervisord重新启动的时候，以前的日志文件会被 清空。当 redirect_stderr=true的时候，sterr也会写进这个日志文件 ;stdout_logfile_maxbytes=1MB ; 日志文件最大大小，和[supervisord]中定义的一样。默认为50 ;stdout_logfile_backups=10 ; 和[supervisord]定义的一样。默认10 ;stdout_capture_maxbytes=1MB ; 这个东西是设定capture管道的大小，当值不为0的时候，子进程可以从stdout 发送信息，而supervisor可以根据信息，发送相应的event。 默认为0，为0的时候表达关闭管道。。。非必须项 ;stdout_events_enabled=false ; 当设置为ture的时候，当子进程由stdout向文件描述符中写日志的时候，将 触发supervisord发送PROCESS_LOG_STDOUT类型的event 默认为false。。。非必须设置 ;stderr_logfile=/a/path ; 这个东西是设置stderr写的日志路径，当redirect_stderr=true。这个就不用 设置了，设置了也是白搭。因为它会被写入stdout_logfile的同一个文件中 默认为AUTO，也就是随便找个地存，supervisord重启被清空。。非必须设置 ;stderr_logfile_maxbytes=1MB ; 这个出现好几次了，就不重复了 ;stderr_logfile_backups=10 ; 这个也是 ;stderr_capture_maxbytes=1MB ; 这个一样，和stdout_capture一样。 默认为0，关闭状态 ;stderr_events_enabled=false ; 这个也是一样，默认为false ;environment=A=\u0026#34;1\u0026#34;,B=\u0026#34;2\u0026#34; ; 这个是该子进程的环境变量，和别的子进程是不共享的 ;serverurl=AUTO ;  ; The below sample eventlistener section shows all possible ; eventlistener subsection values, create one or more \u0026#39;real\u0026#39; ; eventlistener: sections to be able to handle event notifications ; sent by supervisor. ;[eventlistener:theeventlistenername] ;这个东西其实和program的地位是一样的，也是suopervisor启动的子进 程，不过它干的活是订阅supervisord发送的event。他的名字就叫 listener了。我们可以在listener里面做一系列处理，比如报警等等 楼主这两天干的活，就是弄的这玩意 ;command=/bin/eventlistener ; 这个和上面的program一样，表示listener的可执行文件的路径 ;process_name=%(program_name)s ; 这个也一样，进程名，当下面的numprocs为多个的时候，才需要。否则默认就 OK了 ;numprocs=1 ; 相同的listener启动的个数 ;events=EVENT ; event事件的类型，也就是说，只有写在这个地方的事件类型。才会被发送 ;buffer_size=10 ; 这个是event队列缓存大小，单位不太清楚，楼主猜测应该是个吧。当buffer 超过10的时候，最旧的event将会被清除，并把新的event放进去。 默认值为10。。非必须选项 ;directory=/tmp ; 进程执行前，会切换到这个目录下执行 默认为不切换。。。非必须 ;umask=022 ; 淹没，默认为none，不说了 ;priority=-1 ; 启动优先级，默认-1，也不扯了 ;autostart=true ; 是否随supervisord启动一起启动，默认true ;autorestart=unexpected ; 是否自动重启，和program一个样，分true,false,unexpected等，注意 unexpected和exitcodes的关系 ;startsecs=1 ; 也是一样，进程启动后跑了几秒钟，才被认定为成功启动，默认1 ;startretries=3 ; 失败最大尝试次数，默认3 ;exitcodes=0,2 ; 期望或者说预料中的进程退出码， ;stopsignal=QUIT ; 干掉进程的信号，默认为TERM，比如设置为QUIT，那么如果QUIT来干这个进程 那么会被认为是正常维护，退出码也被认为是expected中的 ;stopwaitsecs=10 ; max num secs to wait b4 SIGKILL (default 10) ;stopasgroup=false ; send stop signal to the UNIX process group (default false) ;killasgroup=false ; SIGKILL the UNIX process group (def false) ;user=chrism ;设置普通用户，可以用来管理该listener进程。 默认为空。。非必须设置 ;redirect_stderr=true ; 为true的话，stderr的log会并入stdout的log里面 默认为false。。。非必须设置 ;stdout_logfile=/a/path ; 这个不说了，好几遍了 ;stdout_logfile_maxbytes=1MB ; 这个也是 ;stdout_logfile_backups=10 ; 这个也是 ;stdout_events_enabled=false ; 这个其实是错的，listener是不能发送event ;stderr_logfile=/a/path ; 这个也是 ;stderr_logfile_maxbytes=1MB ; 这个也是 ;stderr_logfile_backups ; 这个不说了 ;stderr_events_enabled=false ; 这个也是错的，listener不能发送event ;environment=A=\u0026#34;1\u0026#34;,B=\u0026#34;2\u0026#34; ; 这个是该子进程的环境变量 默认为空。。。非必须设置 ;serverurl=AUTO ; override serverurl computation (childutils) ; The below sample group section shows all possible group values, ; create one or more \u0026#39;real\u0026#39; group: sections to create \u0026#34;heterogeneous\u0026#34; ; process groups. ;[group:thegroupname] ;这个东西就是给programs分组，划分到组里面的program。我们就不用一个一个去操作了 我们可以对组名进行统一的操作。 注意：program被划分到组里面之后，就相当于原来 的配置从supervisor的配置文件里消失了。。。supervisor只会对组进行管理，而不再 会对组里面的单个program进行管理了 ;programs=progname1,progname2 ; 组成员，用逗号分开 这个是个必须的设置项 ;priority=999 ; 优先级，相对于组和组之间说的 默认999。。非必须选项 ; The [include] section can just contain the \u0026#34;files\u0026#34; setting. This ; setting can list multiple files (separated by whitespace or ; newlines). It can also contain wildcards. The filenames are ; interpreted as relative to this file. Included files *cannot* ; include files themselves. ;[include] ;这个东西挺有用的，当我们要管理的进程很多的时候，写在一个文件里面 就有点大了。我们可以把配置信息写到多个文件中，然后include过来 ;files = relative/directory/*.ini program配置详解\n[program:nginx] directory = /usr/local/bin/ ; 程序的启动目录 command = sudo /usr/local/bin/nginx ; 启动命令，可以看出与手动在命令行启动的命令是一样的 autostart = true ; 在 supervisord 启动的时候也自动启动 startsecs = 5 ; 启动 5 秒后没有异常退出，就当作已经正常启动了 autorestart = true ; 程序异常退出后自动重启 startretries = 3 ; 启动失败自动重试次数，默认是 3 user = root ; 用哪个用户启动 redirect_stderr = true ; 把 stderr 重定向到 stdout，默认 false stdout_logfile_backups = 20 ; stdout 日志文件备份数 ; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件） stdout_logfile=/data/home/supervisor/logs/nginx_stdout.log stdout_logfile_maxbytes=10MB stderr_logfile=/data/home/supervisor/logs/nginx_stderr.log stderr_logfile_maxbytes=10MB ; 可以通过 environment 来添加需要的环境变量，一种常见的用法是修改 PYTHONPATH ; environment=PYTHONPATH=$PYTHONPATH:/path/to/somewhere 一份配置文件至少需要一个 [program:x] 部分的配置，来告诉 supervisord 需要管理那个进程。[program:x] 语法中的 x 表示 program name，会在客户端（supervisorctl 或 web 界面）显示，在 supervisorctl 中通过这个值来对程序进行 start、restart、stop 等操作。\nsupervisorctl常用命令\nstatus # 查看程序状态 stop usercenter # 关闭 usercenter 程序 start usercenter # 启动 usercenter 程序 restart usercenter # 重启 usercenter 程序 reread ＃ 读取有更新（增加）的配置文件，不会启动新添加的程序 update ＃ 重启配置文件修改过的程序 参考： http://supervisord.org/configuration.html  http://liyangliang.me/posts/2015/06/using-supervisor\nhttp://lixcto.blog.51cto.com/4834175/1539136\n","id":8,"section":"posts","summary":"mac下使用supervisor 安装 使用brew进行 安装 $ brew install supervisor ==\u0026gt; Downloading http://7xkcej.dl1.z0.glb.clouddn.com/bottles/supervisor-3.3.1.sierra.bottle.tar.gz ######################################################################## 100.0% ==\u0026gt; Pouring supervisor-3.3.1.sierra.bottle.tar.gz ==\u0026gt; Using the sandbox ==\u0026gt; Caveats To have launchd start supervisor now and restart at login: brew services start supervisor Or, if you don\u0026#39;t want/need a background service you can","tags":["supervisor"],"title":"mac下使用supervisor","uri":"https://blog.fengjx.com/mac-supervisor/","year":"2018"},{"content":"How To Ask Questions The Smart Way\nCopyright © 2001,2006,2014 Eric S. Raymond, Rick Moen\n本指南英文版版权为 Eric S. Raymond, Rick Moen 所有。\n原文网址：http://www.catb.org/~esr/faqs/smart-questions.html\nCopyleft 2001 by D.H.Grand(nOBODY/Ginux), 2010 by Gasolin, 2015 by Ryan Wu\n本中文指南是基于原文 3.10 版以及 2010 年由 Gasolin 所翻译版本的最新翻译；\n本文另有繁體中文版。\n原文版本历史 声明 许多项目在他们的使用协助/说明网页中链接了本指南，这么做很好，我们也鼓励大家都这么做。但如果你是负责管理这个项目网页的人，请在超链接附近的显著位置上注明：\n本指南不提供此项目的实际支持服务！\n我们已经深刻领教到少了上述声明所带来的痛苦。因为少了这点声明，我们不停地被一些白痴纠缠。这些白痴认为既然我们发布了这本指南，那么我们就有责任解决世上所有的技术问题。\n如果你是因为需要某些协助而正在阅读这本指南，并且最后离开是因为发现从本指南作者们身上得不到直接的协助，那么你就是我们所说的那些白痴之一。别问我们问题，我们只会忽略你。我们在这本指南中是教你如何从那些真正懂得你所遇到软件或硬件问题的人取得协助，而 99% 的情况下那不会是我们。除非你确定本指南的作者之一刚好是你所遇到的问题领域的专家，否则请不要打扰我们，这样大家都会开心一点。\n简介 在黑客的世界里，当你拋出一个技术问题时，最终是否能得到有用的回答，往往取决于你所提问和追问的方式。本指南将教你如何正确的提问以获得你满意的答案。\n不只是黑客，现在开放源代码（Open Source）软件已经相当盛行，你常常也可以由其他有经验的使用者身上得到好答案，这是件好事；使用者比起黑客来，往往对那些新手常遇到的问题更宽容一些。然而，将有经验的使用者视为黑客，并采用本指南所提的方法与他们沟通，同样也是能从他们身上得到满意回答的最有效方式。\n首先你应该明白，黑客们喜爱有挑战性的问题，或者能激发他们思维的好问题。如果我们并非如此，那我们也不会成为你想询问的对象。如果你给了我们一个值得反复咀嚼玩味的好问题，我们自会对你感激不尽。好问题是激励，是厚礼。好问题可以提高我们的理解力，而且通常会暴露我们以前从没意识到或者思考过的问题。对黑客而言，\u0026ldquo;好问题！\u0026ldquo;是诚挚的大力称赞。\n尽管如此，黑客们有着蔑视或傲慢面对简单问题的坏名声，这有时让我们看起来对新手、无知者似乎较有敌意，但其实不是那样的。\n我们不讳言我们对那些不愿思考、或者在发问前不做他们该做的事的人的蔑视。那些人是时间杀手 -– 他们只想索取，从不付出，消耗我们可用在更有趣的问题或更值得回答的人身上的时间。我们称这样的人为 失败者（撸瑟） （由于历史原因，我们有时把它拼作 lusers）。\n我们意识到许多人只是想使用我们写的软件，他们对学习技术细节没有兴趣。对大多数人而言，电脑只是种工具，是种达到目的的手段而已。他们有自己的生活并且有更要紧的事要做。我们了解这点，也从不指望每个人都对这些让我们着迷的技术问题感兴趣。尽管如此，我们回答问题的风格是指向那些真正对此有兴趣并愿意主动参与解决问题的人，这一点不会变，也不该变。如果连这都变了，我们就是在降低做自己最擅长的事情上的效率。\n我们（在很大程度上）是自愿的，从繁忙的生活中抽出时间来解答疑惑，而且时常被提问淹没。所以我们无情的滤掉一些话题，特别是拋弃那些看起来像失败者的家伙，以便更高效的利用时间来回答赢家（winner）的问题。\n如果你厌恶我们的态度，高高在上，或过于傲慢，不妨也设身处地想想。我们并没有要求你向我们屈服 \u0026ndash; 事实上，我们大多数人非常乐意与你平等地交流，只要你付出小小努力来满足基本要求，我们就会欢迎你加入我们的文化。但让我们帮助那些不愿意帮助自己的人是没有效率的。无知没有关系，但装白痴就是不行。\n所以，你不必在技术上很在行才能吸引我们的注意，但你必须表现出能引导你变得在行的特质 \u0026ndash; 机敏、有想法、善于观察、乐于主动参与解决问题。如果你做不到这些使你与众不同的事情，我们建议你花点钱找家商业公司签个技术支持服务合同，而不是要求黑客个人无偿地帮助你。\n如果你决定向我们求助，当然你也不希望被视为失败者，更不愿成为失败者中的一员。能立刻得到快速并有效答案的最好方法，就是像赢家那样提问 \u0026ndash; 聪明、自信、有解决问题的思路，只是偶尔在特定的问题上需要获得一点帮助。\n（欢迎对本指南提出改进意见。你可以 email 你的建议至 esr@thyrsus.com 或 respond-auto@linuxmafia.com。然而请注意，本文并非网络礼节的通用指南，而我们通常会拒绝无助于在技术论坛得到有用答案的建议。）\n在提问之前 在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情：\n 尝试在你准备提问的论坛的旧文章中搜索答案。 尝试上网搜索以找到答案。 尝试阅读手册以找到答案。 尝试阅读常见问题文件（FAQ）以找到答案。 尝试自己检查或试验以找到答案 向你身边的强者朋友打听以找到答案。 如果你是程序开发者，请尝试阅读源代码以找到答案。  当你提出问题的时候，请先表明你已经做了上述的努力；这将有助于树立你并不是一个不劳而获且浪费别人的时间的提问者。如果你能一并表达在做了上述努力的过程中所学到的东西会更好，因为我们更乐于回答那些表现出能从答案中学习的人的问题。\n运用某些策略，比如先用 Google 搜索你所遇到的各种错误信息（既搜索 Google 论坛，也搜索网页），这样很可能直接就找到了能解决问题的文件或邮件列表线索。即使没有结果，在邮件列表或新闻组寻求帮助时加上一句 我在 Google 中搜过下列句子但没有找到什么有用的东西 也是件好事，即使它只是表明了搜索引擎不能提供哪些帮助。这么做（加上搜索过的字串）也让遇到相似问题的其他人能被搜索引擎引导到你的提问来。\n别着急，不要指望几秒钟的 Google 搜索就能解决一个复杂的问题。在向专家求助之前，再阅读一下常见问题文件（FAQ）、放轻松、坐舒服一些，再花点时间思考一下这个问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑拋出，只因你的第一次搜索没有找到答案（或者找到太多答案）。\n准备好你的问题，再将问题仔细的思考过一遍，因为草率的发问只能得到草率的回答，或者根本得不到任何答案。越是能表现出在寻求帮助前你为解决问题所付出的努力，你越有可能得到实质性的帮助。\n小心别问错了问题。如果你的问题基于错误的假设，某个普通黑客（J. Random Hacker）多半会一边在心里想着蠢问题…， 一边用无意义的字面解释来答复你，希望着你会从问题的回答（而非你想得到的答案）中汲取教训。\n绝不要自以为够格得到答案，你没有；你并没有。毕竟你没有为这种服务支付任何报酬。你将会是自己去挣到一个答案，靠提出有内涵的、有趣的、有思维激励作用的问题 \u0026ndash;一个有潜力能贡献社区经验的问题，而不仅仅是被动的从他人处索取知识。\n另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。谁能给点提示？、我的这个例子里缺了什么？以及我应该检查什么地方比请把我需要的确切的过程贴出来更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。\n当你提问时 慎选提问的论坛 小心选择你要提问的场合。如果你做了下述的事情，你很可能被忽略掉或者被看作失败者：\n 在与主题不合的论坛上贴出你的问题 在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然 在太多的不同新闻群组上重复转贴同样的问题（cross-post） 向既非熟人也没有义务解决你问题的人发送私人电邮  黑客会剔除掉那些搞错场合的问题，以保护他们沟通的渠道不被无关的东西淹没。你不会想让这种事发生在自己身上的。\n因此，第一步是找到对的论坛。再说一次，Google 和其它搜索引擎还是你的朋友，用它们来找到与你遭遇到困难的软硬件问题最相关的网站。通常那儿都有常见问题（FAQ）、邮件列表及相关说明文件的链接。如果你的努力（包括阅读 FAQ）都没有结果，网站上也许还有报告 Bug（Bug-reporting）的流程或链接，如果是这样，链过去看看。\n向陌生的人或论坛发送邮件最可能是风险最大的事情。举例来说，别假设一个提供丰富内容的网页的作者会想充当你的免费顾问。不要对你的问题是否会受到欢迎做太乐观的估计 \u0026ndash; 如果你不确定，那就向别处发送，或者压根别发。\n在选择论坛、新闻群组或邮件列表时，别太相信名字，先看看 FAQ 或者许可书以弄清楚你的问题是否切题。发文前先翻翻已有的话题，这样可以让你感受一下那里的文化。事实上，事先在新闻组或邮件列表的历史记录中搜索与你问题相关的关键词是个极好的主意，也许这样就找到答案了。即使没有，也能帮助你归纳出更好的问题。\n别像机关枪似的一次\u0026quot;扫射\u0026quot;所有的帮助渠道，这就像大喊大叫一样会使人不快。要一个一个地来。\n搞清楚你的主题！最典型的错误之一是在某种致力于跨平台可移植的语言、套件或工具的论坛中提关于 Unix 或 Windows 操作系统程序界面的问题。如果你不明白为什么这是大错，最好在搞清楚这之间差异之前什么也别问。\n一般来说，在仔细挑选的公共论坛中提问，会比在私有论坛中提同样的问题更容易得到有用的回答。有几个理由可以支持这点，一是看潜在的回复者有多少，二是看观众有多少。黑客较愿意回答那些能帮助到许多人的问题。\n可以理解的是，老练的黑客和一些热门软件的作者正在接受过多的错发信息。就像那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端 \u0026ndash; 已经好几次了，一些热门软件的作者从自己软件的支持中抽身出来，因为伴随而来涌入其私人邮箱的无用邮件变得无法忍受。\nStack Overflow 搜索，然后 在 Stack Exchange 问。\n近年来，Stack Exchange community 社区已经成为回答技术及其他问题的主要渠道，尤其是那些开放源码的项目。\n因为 Google 索引是即时的，在看 Stack Exchange 之前先在 Google 搜索。有很高的机率某人已经问了一个类似的问题，而且 Stack Exchange 网站们往往会是搜索结果中最前面几个。如果你在 Google 上没有找到任何答案，你再到特定相关主题的网站去找。用标签（Tag）搜索能让你更缩小你的搜索结果。\nStack Exchange 已经成长到超过一百个网站，以下是最常用的几个站：\n Super User 是问一些通用的电脑问题，如果你的问题跟代码或是写程序无关，只是一些网络连线之类的，请到这里。 Stack Overflow 是问写程序有关的问题。 Server Fault 是问服务器和网管相关的问题。  网站和 IRC 论坛 本地的使用者群组（user group），或者你所用的 Linux 发行版本也许正在宣传他们的网页论坛或 IRC 频道，并提供新手帮助（在一些非英语国家，新手论坛很可能还是邮件列表）， 这些地方是开始提问的好首选，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。有广告赞助的 IRC 频道是公开欢迎提问的地方，通常可以即时得到回应。\n事实上，如果程序出的问题只发生在特定 Linux 发行版提供的版本（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的论坛或邮件列表提问。（否则）该项目的黑客可能仅仅回复 \u0026ldquo;用我们的版本\u0026rdquo;。\n在任何论坛发文以前，先确认一下有没有搜索功能。如果有，就试着搜索一下问题的几个关键词，也许这会有帮助。如果在此之前你已做过通用的网页搜索（你也该这样做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。\n通过论坛或 IRC 频道来提供使用者支持服务有增长的趋势，电子邮件则大多为项目开发者间的交流而保留。所以最好先在论坛或 IRC 中寻求与该项目相关的协助。\n在使用 IRC 的时候，首先最好不要发布很长的问题描述，有些人称之为频道洪水。最好通过一句话的问题描述来开始聊天。\n第二步，使用项目邮件列表 当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文件和首页，找到项目的邮件列表并使用它。有几个很好的理由支持我们采用这种办法：\n 任何好到需要向个别开发者提出的问题，也将对整个项目群组有益。反之，如果你认为自己的问题对整个项目群组来说太愚蠢，也不能成为骚扰个别开发者的理由。 向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导人）也许太忙以至于没法回答你的问题。 大多数邮件列表都会被存档，那些被存档的内容将被搜索引擎索引。如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。 如果某些问题经常被问到，开发者可以利用此信息来改进说明文件或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。  如果一个项目既有\u0026quot;使用者\u0026rdquo; 也有\u0026quot;开发者\u0026rdquo;（或\u0026quot;黑客\u0026rdquo;）邮件列表或论坛，而你又不会动到那些源代码，那么就向\u0026quot;使用者\u0026quot;列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会将你的提问视为干扰他们开发的噪音。\n然而，如果你确信你的问题很特别，而且在\u0026quot;使用者\u0026rdquo; 列表或论坛中几天都没有回复，可以试试前往\u0026quot;开发者\u0026quot;列表或论坛发问。建议你在张贴前最好先暗地里观察几天以了解那里的行事方式（事实上这是参与任何私有或半私有列表的好主意）\n如果你找不到一个项目的邮件列表，而只能查到项目维护者的电子邮件地址，尽管向他发信。即使是在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中，请陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。\n使用有意义且描述明确的标题 在邮件列表、新闻群组或论坛中，大约 50 字以内的标题是抓住资深专家注意力的好机会。别用喋喋不休的帮帮忙、跪求、急（更别说救命啊！！！！这样让人反感的话，用这种标题会被条件反射式地忽略）来浪费这个机会。不要妄想用你的痛苦程度来打动我们，而应该是在这点空间中使用极简单扼要的描述方式来提出问题。\n一个好标题范例是目标 -- 差异式的描述，许多技术支持组织就是这样做的。在目标部分指出是哪一个或哪一组东西有问题，在差异部分则描述与期望的行为不一致的地方。\n 蠢问题：救命啊！我的笔记本电脑不能正常显示了！\n  聪明问题：X.org 6.8.1 的鼠标光标会变形，某牌显卡 MV1005 芯片组。\n  更聪明问题：X.org 6.8.1 的鼠标光标，在某牌显卡 MV1005 芯片组环境下 - 会变形。\n 编写目标 -- 差异 式描述的过程有助于你组织对问题的细致思考。是什么被影响了？ 仅仅是鼠标光标或者还有其它图形？只在 X.org 的 X 版中出现？或只是出现在 6.8.1 版中？ 是针对某牌显卡芯片组？或者只是其中的 MV1005 型号？ 一个黑客只需瞄一眼就能够立即明白你的环境和你遇到的问题。\n总而言之，请想像一下你正在一个只显示标题的存档讨论串（Thread）索引中查寻。让你的标题更好地反映问题，可使下一个搜索类似问题的人能够关注这个讨论串，而不用再次提问相同的问题。\n如果你想在回复中提出问题，记得要修改内容标题，以表明你是在问一个问题， 一个看起来像 Re: 测试 或者 Re: 新 bug 的标题很难引起足够重视。另外，在不影响连贯性之下，适当引用并删减前文的内容，能给新来的读者留下线索。\n对于讨论串，不要直接点击回复来开始一个全新的讨论串，这将限制你的观众。因为有些邮件阅读程序，比如 mutt ，允许使用者按讨论串排序并通过折叠讨论串来隐藏消息，这样做的人永远看不到你发的消息。\n仅仅改变标题还不够。mutt 和其它一些邮件阅读程序还会检查邮件标题以外的其它信息，以便为其指定讨论串。所以宁可发一个全新的邮件。\n在网页论坛上，好的提问方式稍有不同，因为讨论串与特定的信息紧密结合，并且通常在讨论串外就看不到里面的内容，故通过回复提问，而非改变标题是可接受的。不是所有论坛都允许在回复中出现分离的标题，而且这样做了基本上没有人会去看。不过，通过回复提问，这本身就是暧昧的做法，因为它们只会被正在查看该标题的人读到。所以，除非你只想在该讨论串当前活跃的人群中提问，不然还是另起炉灶比较好。\n使问题容易回复 以请将你的回复寄到……来结束你的问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟思考你的问题更麻烦。如果你的邮件程序不支持这样做，换个好点的；如果是操作系统不支持这种邮件程序，也换个好点的。\n在论坛，要求通过电子邮件回复是非常无礼的，除非你相信回复的信息可能比较敏感（而且有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复讨论串时得到电子邮件提醒，可以要求网页论坛发送给你。几乎所有论坛都支持诸如追踪此讨论串、有回复时发送邮件提醒等功能。\n用清晰、正确、精准并语法正确的语句 我们从经验中发现，粗心的提问者通常也会粗心的写程序与思考（我敢打包票）。回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。\n正确的拼字、标点符号和大小写是很重要的。一般来说，如果你觉得这样做很麻烦，不想在乎这些，那我们也觉得麻烦，不想在乎你的提问。花点额外的精力斟酌一下字句，用不着太僵硬与正式 \u0026ndash; 事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它必须很准确，而且有迹象表明你是在思考和关注问题。\n正确地拼写、使用标点和大小写，不要将its混淆为it's，loose搞成lose或者将discrete弄成discreet。不要全部用大写，这会被视为无礼的大声嚷嚷（全部小写也好不到哪去，因为不易阅读。Alan Cox 也许可以这样做，但你不行。）\n更白话的说，如果你写得像是个半文盲[译注：小白]，那多半得不到理睬。也不要使用即时通讯中的简写或火星文，如将的简化为ㄉ会使你看起来像一个为了少打几个键而省字的小白。更糟的是，如果像个小孩似地鬼画符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。\n如果在使用非母语的论坛提问，你可以犯点拼写和语法上的小错，但决不能在思考上马虎（没错，我们通常能弄清两者的分别）。同时，除非你知道回复者使用的语言，否则请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂语言写的消息。在网络上英语是通用语言，用英语书写可以将你的问题在尚未被阅读就被直接删除的可能性降到最低。\n如果英文是你的外语（Second language），提示潜在回复者你有潜在的语言困难是很好的： [译注：以下附上原文以供使用]\n English is not my native language; please excuse typing errors.\n  英文不是我的母语，请原谅我的错字或语法   If you speak $LANGUAGE, please email/PM me; I may need assistance translating my question.\n  如果你说某语言，请寄信/私讯给我；我需要有人协助我翻译我的问题   I am familiar with the technical terms, but some slang expressions and idioms are difficult for me.\n  我对技术名词很熟悉，但对于俗语或是特别用法比较不甚了解。   I\u0026rsquo;ve posted my question in $LANGUAGE and English. I\u0026rsquo;ll be glad to translate responses, if you only use one or the other.\n  我把我的问题用某语言和英文写出来，如果你只用一种语言回答，我会乐意将其翻译成另一种。  使用易于读取且标准的文件格式发送问题 如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以：\n 使用纯文字而不是 HTML (关闭 HTML 并不难）。 使用 MIME 附件通常是可以的，前提是真正有内容（譬如附带的源代码或 patch），而不仅仅是邮件程序生成的模板（譬如只是信件内容的拷贝）。 不要发送一段文字只是一行句子但自动换行后会变成多行的邮件（这使得回复部分内容非常困难）。设想你的读者是在 80 个字符宽的终端机上阅读邮件，最好设置你的换行分割点小于 80 字。 但是，对一些特殊的文件不要设置固定宽度（譬如日志档案拷贝或会话记录）。数据应该原样包含，让回复者有信心他们看到的是和你看到的一样的东西。 在英语论坛中，不要使用Quoted-Printable MIME 编码发送消息。这种编码对于张贴非 ASCII 语言可能是必须的，但很多邮件程序并不支持这种编码。当它们处理换行时，那些文本中四处散布的=20符号既难看也分散注意力，甚至有可能破坏内容的语意。 绝对，永远不要指望黑客们阅读使用封闭格式编写的文档，像微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就像有人将还在冒热气的猪粪倒在你家门口时你的反应一样。即便他们能够处理，他们也很厌恶这么做。 如果你从使用 Windows 的电脑发送电子邮件，关闭微软愚蠢的智能引号功能 （从[选项] \u0026gt; [校订] \u0026gt; [自动校正选项]，勾选掉智能引号单选框），以免在你的邮件中到处散布垃圾字符。 在论坛，勿滥用表情符号和HTML功能（当它们提供时）。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来像个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是对答案感兴趣。  如果你使用图形用户界面的邮件程序（如微软公司的 Outlook 或者其它类似的），注意它们的默认设置不一定满足这些要求。大多数这类程序有基于选单的查看源代码命令，用它来检查发送文件夹中的邮件，以确保发送的是纯文本文件同时没有一些奇怪的字符。\n精确的描述问题并言之有物  仔细、清楚地描述你的问题或 Bug 的症状。 描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：Fedora Core 4、Slackware 9.1等）。 描述在提问前你是怎样去研究和理解这个问题的。 描述在提问前为确定问题而采取的诊断步骤。 描述最近做过什么可能相关的硬件或软件变更。 尽可能的提供一个可以重现这个问题的可控环境的方法。  尽量去揣测一个黑客会怎样反问你，在你提问之前预先将黑客们可能遇到的问题回答一遍。\n以上几点中，当你报告的是你认为可能在代码中的问题时，给黑客一个可以重现你的问题的环境尤其重要。当你这么做时，你得到有效的回答的机会和速度都会大大的提升。\nSimon Tatham 写过一篇名为《如何有效的报告 Bug》的出色文章。强力推荐你也读一读。\n话不在多而在精 你需要提供精确有内容的信息。这并不是要求你简单的把成堆的出错代码或者资料完全转录到你的提问中。如果你有庞大而复杂的测试样例能重现程序挂掉的情境，尽量将它剪裁得越小越好。\n这样做的用处至少有三点。 第一，表现出你为简化问题付出了努力，这可以使你得到回答的机会增加； 第二，简化问题使你更有可能得到有用的答案； 第三，在精炼你的 bug 报告的过程中，你很可能就自己找到了解决方法或权宜之计。\n别动辄声称找到 Bug 当你在使用软件中遇到问题，除非你非常、非常的有根据，不要动辄声称找到了 Bug。提示：除非你能提供解决问题的源代码补丁，或者提供回归测试来表明前一版本中行为不正确，否则你都多半不够完全确信。这同样适用在网页和文件，如果你（声称）发现了文件的Bug，你应该能提供相应位置的修正或替代文件。\n请记得，还有许多其它使用者没遇到你发现的问题，否则你在阅读文件或搜索网页时就应该发现了（你在抱怨前已经做了这些，是吧？）。这也意味着很有可能是你弄错了而不是软件本身有问题。\n编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了 Bug，也就是在质疑他们的能力，即使你是对的，也有可能会冒犯到其中某部分人。当你在标题中嚷嚷着有Bug时，这尤其严重。\n提问时，即使你私下非常确信已经发现一个真正的 Bug，最好写得像是你做错了什么。如果真的有 Bug，你会在回复中看到这点。这样做的话，如果真有 Bug，维护者就会向你道歉，这总比你惹恼别人然后欠别人一个道歉要好一点。\n低声下气不能代替你的功课 有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 \u0026ndash; 低声下气：我知道我只是个可悲的新手，一个撸瑟，但...。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描述时更令人反感。\n别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。\n有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。\n描述问题症状而非你的猜测 告诉黑客们你认为问题是怎样造成的并没什么帮助。（如果你的推断如此有效，还用向别人求助吗？），因此要确信你原原本本告诉了他们问题的症状，而不是你的解释和理论；让黑客们来推测和诊断。如果你认为陈述自己的猜测很重要，清楚地说明这只是你的猜测，并描述为什么它们不起作用。\n蠢问题\n 我在编译内核时接连遇到 SIG11 错误， 我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？\n 聪明问题\n 我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6/233 CPU（威盛 Apollo VP2 芯片组）， 256MB Corsair PC133 SDRAM 内存，在编译内核时，从开机 20 分钟以后就频频产生 SIG11 错误， 但是在头 20 分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作 20 分钟。 所有内存都换过了，没有效果。相关部分的标准编译记录如下…。\n 由于以上这点似乎让许多人觉得难以配合，这里有句话可以提醒你：所有的诊断专家都来自密苏里州。 美国国务院的官方座右铭则是：让我看看（出自国会议员 Willard D. Vandiver 在 1899 年时的讲话：我来自一个出产玉米，棉花，牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。） 针对诊断者而言，这并不是一种怀疑，而只是一种真实而有用的需求，以便让他们看到的是与你看到的原始证据尽可能一致的东西，而不是你的猜测与归纳的结论。所以，大方的展示给我们看吧！\n按发生时间先后列出问题症状 问题发生前的一系列操作，往往就是对找出问题最有帮助的线索。因此，你的说明里应该包含你的操作步骤，以及机器和软件的反应，直到问题发生。在命令行处理的情况下，提供一段操作记录（例如运行脚本工具所生成的），并引用相关的若干行（如 20 行）记录会非常有帮助。\n如果挂掉的程序有诊断选项（如 -v 的详述开关），试着选择这些能在记录中增加调试信息的选项。记住，多不等于好。试着选取适当的调试级别以便提供有用的信息而不是让读者淹没在垃圾中。\n如果你的说明很长（如超过四个段落），在开头简述问题，接下来再按时间顺序详述会有所帮助。这样黑客们在读你的记录时就知道该注意哪些内容了。\n描述目标而不是过程 如果你想弄清楚如何做某事（而不是报告一个 Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。\n经常寻求技术帮助的人在心中有个更高层次的目标，而他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身就有问题。结果要费很大的劲才能搞定。\n蠢问题\n 我怎样才能从某绘图程序的颜色选择器中取得十六进制的的 RGB 值？\n 聪明问题\n 我正试着用替换一幅图片的色码（color table）成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块（table slot）， 但却无法从某绘图程序的颜色选择器取得十六进制的的 RGB 值。\n 第二种提问法比较聪明，你可能得到像是建议采用另一个更合适的工具的回复。\n别要求使用私人电邮回复 黑客们认为问题的解决过程应该公开、透明，此过程中如果更有经验的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为提供帮助者可以得到一些奖励，奖励就是他的能力和学识被其他同行看到。\n当你要求私下回复时，这个过程和奖励都被中止。别这样做，让回复者来决定是否私下回答 \u0026ndash; 如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于对其它人没有兴趣。\n这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么这个神奇的提问句会是向我发电邮，我将为论坛归纳这些回复。试着将邮件列表或新闻群组从洪水般的雷同回复中解救出来是非常有礼貌的 \u0026ndash; 但你必须信守诺言。\n清楚明确的表达你的问题以及需求 漫无边际的提问是近乎无休无止的时间黑洞。最有可能给你有用答案的人通常也正是最忙的人（他们忙是因为要亲自完成大部分工作）。这样的人对无节制的时间黑洞相当厌恶，所以他们也倾向于厌恶那些漫无边际的提问。\n如果你明确表述需要回答者做什么（如提供指点、发送一段代码、检查你的补丁、或是其他等等），就最有可能得到有用的答案。因为这会定出一个时间和精力的上限，便于回答者能集中精力来帮你。这么做很棒。\n要理解专家们所处的世界，请把专业技能想像为充裕的资源，而回复的时间则是稀缺的资源。你要求他们奉献的时间越少，你越有可能从真正专业而且很忙的专家那里得到解答。\n所以，界定一下你的问题，使专家花在辨识你的问题和回答所需要付出的时间减到最少，这技巧对你有用答案相当有帮助 \u0026ndash; 但这技巧通常和简化问题有所区别。因此，问我想更好的理解 X，可否指点一下哪有好一点说明？通常比问你能解释一下 X 吗？更好。如果你的代码不能运作，通常请别人看看哪里有问题，比要求别人替你改正要明智得多。\n询问有关代码的问题时 别要求他人帮你调试有问题的代码，不提示一下应该从何入手。张贴几百行的代码，然后说一声：它不能工作会让你完全被忽略。只贴几十行代码，然后说一句：在第七行以后，我期待它显示 \u0026lt;x\u0026gt;，但实际出现的是 \u0026lt;y\u0026gt;比较有可能让你得到回应。\n最有效描述程序问题的方法是提供最精简的 Bug 展示测试用例（bug-demonstrating test case）。什么是最精简的测试用例？那是问题的缩影；一小个程序片段能刚好展示出程序的异常行为，而不包含其他令人分散注意力的内容。怎么制作最精简的测试用例？如果你知道哪一行或哪一段代码会造成异常的行为，复制下来并加入足够重现这个状况的代码（例如，足以让这段代码能被编译/直译/被应用程序处理）。如果你无法将问题缩减到一个特定区块，就复制一份代码并移除不影响产生问题行为的部分。总之，测试用例越小越好（查看话不在多而在精一节）。\n一般而言，要得到一段相当精简的测试用例并不太容易，但永远先尝试这样做的是种好习惯。这种方式可以帮助你了解如何自行解决这个问题 —- 而且即使你的尝试不成功，黑客们也会看到你在尝试取得答案的过程中付出了努力，这可以让他们更愿意与你合作。\n如果你只是想让别人帮忙审查（Review）一下代码，在信的开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。\n别把自己家庭作业的问题贴上来 黑客们很擅长分辨哪些问题是家庭作业式的问题；因为我们中的大多数都曾自己解决这类问题。同样，这些问题得由你来搞定，你会从中学到东西。你可以要求给点提示，但别要求得到完整的解决方案。\n如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在使用者群组，论坛或（最后一招）在项目的使用者邮件列表或论坛中提问。尽管黑客们会看出来，但一些有经验的使用者也许仍会给你一些提示。\n去掉无意义的提问句 避免用无意义的话结束提问，例如有人能帮我吗？或者这有答案吗？。\n首先：如果你对问题的描述不是很好，这样问更是画蛇添足。\n其次：由于这样问是画蛇添足，黑客们会很厌烦你 \u0026ndash; 而且通常会用逻辑上正确，但毫无意义的回答来表示他们的蔑视， 例如：没错，有人能帮你或者不，没答案。\n一般来说，避免用 是或否、对或错、有或没有类型的问句，除非你想得到是或否类型的回答。\n即使你很急也不要在标题写紧急 这是你的问题，不是我们的。宣称紧急极有可能事与愿违：大多数黑客会直接删除无礼和自私地企图即时引起关注的问题。更严重的是，紧急这个字（或是其他企图引起关注的标题）通常会被垃圾信过滤器过滤掉 \u0026ndash; 你希望能看到你问题的人可能永远也看不到。\n有半个例外的情况是，如果你是在一些很高调，会使黑客们兴奋的地方，也许值得这样去做。在这种情况下，如果你有时间压力，也很有礼貌地提到这点，人们也许会有兴趣回答快一点。\n当然，这风险很大，因为黑客们兴奋的点多半与你的不同。譬如从 NASA 国际空间站（International Space Station）发这样的标题没有问题，但用自我感觉良好的慈善行为或政治原因发肯定不行。事实上，张贴诸如紧急：帮我救救这个毛绒绒的小海豹！肯定让你被黑客忽略或惹恼他们，即使他们认为毛绒绒的小海豹很重要。\n如果你觉得这点很不可思议，最好再把这份指南剩下的内容多读几遍，直到你弄懂了再\n","id":9,"section":"posts","summary":"How To Ask Questions The Smart Way Copyright © 2001,2006,2014 Eric S. Raymond, Rick Moen 本指南英文版版权为 Eric S. Raymond, Rick Moen 所有。 原文网址：http://www.catb.org/~esr/faqs/sma","tags":null,"title":"提问的智慧","uri":"https://blog.fengjx.com/how-to-ask-questions-the-smart-way/","year":"2018"},{"content":" 最新稳定版： https://www.google.com/intl/zh-CN/chrome/browser/?standalone=1\n最新测试版： https://www.google.com/intl/zh-CN/chrome/browser/?standalone=1\u0026amp;extra=betachannel\n最新开发版： https://www.google.com/intl/zh-CN/chrome/browser/?standalone=1\u0026amp;extra=devchannel\n另外,在ubuntu下可以安装chromium\nsudo add-apt-repository ppa:chromium-daily sudo apt-get update sudo apt-get install chromium-browser ","id":10,"section":"posts","summary":"最新稳定版： https://www.google.com/intl/zh-CN/chrome/browser/?standalone=1 最新测试版： https://www.google.com/intl/zh-CN/chrome/browser/?standalone=1\u0026amp;extra=betachannel 最新开发版： https://www.google.com/intl/zh-CN/chrome/browser/?standalone=1\u0026amp;extra=devchannel 另外,在ubuntu下可以安装chromium sudo add-apt-repository ppa:chromium-daily sudo apt-get update sudo apt-get install chromium-browser","tags":["google"],"title":"chrome离线安装包下载","uri":"https://blog.fengjx.com/chrome-download/","year":"2018"},{"content":"sudo apt-get purge libreoffice? 或\nsudo aptitude purge libreoffice? 不要漏掉通配符“?”，否则无法清除/卸载全部 LibreOffice 软件包\n或者\nsudo apt-get remove --purge libreoffice* ","id":11,"section":"posts","summary":"sudo apt-get purge libreoffice? 或 sudo aptitude purge libreoffice? 不要漏掉通配符“?”，否则无法清除/卸载全部 LibreOffice 软件包 或者 sudo apt-get remove --purge libreoffice*","tags":["ububtu","LibreOffice"],"title":"ubuntu下彻底卸载LibreOffice方法","uri":"https://blog.fengjx.com/ubuntu-uninstall-libreoffice/","year":"2016"},{"content":"Git常用操作命令：\n1) 远程仓库相关命令\n# 检出仓库： $ git clone git://github.com/jquery/jquery.git #查看远程仓库： $ git remote -v # 添加远程仓库： $ git remote add [name] [url] # 删除远程仓库： $ git remote rm [name] # 修改远程仓库： $ git remote set-url --push [name] [newUrl] # 拉取远程仓库： $ git pull [remoteName] [localBranchName] # 推送远程仓库： $ git push [remoteName] [localBranchName] *如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，如下： # 提交本地test分支作为远程的master分支 $git push origin test:master # 提交本地test分支作为远程的test分支 $git push origin test:test 2）分支(branch)操作相关命令\n# 查看本地分支： $ git branch # 查看远程分支： $ git branch -r # 创建本地分支： $ git branch [name] ----注意新分支创建后不会自动切换为当前分支 # 切换分支： $ git checkout [name] # 创建新分支并立即切换到新分支： $ git checkout -b [name] # 删除分支： $ git branch -d [name] ---- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项 # 合并分支： $ git merge [name] ----将名称为[name]的分支与当前分支合并 # 创建远程分支(本地分支push到远程)： $ git push origin [name] # 删除远程分支： $ git push origin :heads/[name] 或 $ gitpush origin :[name] *创建空的分支：(执行命令之前记得先提交你当前分支的修改，否则会被强制删干净没得后悔) $git symbolic-ref HEAD refs/heads/[name] $rm .git/index $git clean -fdx 3）版本(tag)操作相关命令\n# 查看版本： $ git tag # 创建版本： $ git tag [name] # 删除版本： $ git tag -d [name] # 查看远程版本： $ git tag -r # 创建远程版本(本地版本push到远程)： $ git push origin [name] # 删除远程版本： $ git push origin :refs/tags/[name] # 合并远程仓库的tag到本地： $ git pull origin --tags # 上传本地tag到远程仓库： $ git push origin --tags # 创建带注释的tag： $ git tag -a [name] -m \u0026#39;yourMessage\u0026#39; 4) 子模块(submodule)相关操作命令\n添加子模块：$ git submodule add [url] [path] 如：$git submodule add git://github.com/soberh/ui-libs.git src/main/webapp/ui-libs 初始化子模块：$ git submodule init ----只在首次检出仓库时运行一次就行 更新子模块：$ git submodule update ----每次更新或切换分支后都需要运行一下 删除子模块：（分4步走哦） 1) $ git rm --cached [path] 2) 编辑“.gitmodules”文件，将子模块的相关配置节点删除掉 3) 编辑“ .git/config”文件，将子模块的相关配置节点删除掉 4) 手动删除子模块残留的目录 5）忽略一些文件、文件夹不提交\n# 在仓库根目录下创建名称为“.gitignore”的文件，写入不需要的文件夹名或文件，每个元素占一行即可，如 target bin *.db =====================\nGit 常用命令\n git branch 查看本地所有分支 git status 查看当前状态 git commit 提交 git branch -a 查看所有的分支 git branch -r 查看本地所有分支 git commit -am \u0026quot;init\u0026quot; 提交并且加注释 git remote add origin git@192.168.1.119:ndshow git push origin master 将文件给推到服务器上 git remote show origin 显示远程库origin里的资源 git push origin master:develop git push origin master:hb-dev 将本地库与服务器上的库进行关联 git checkout --track origin/dev 切换到远程dev分支 git branch -D master develop 删除本地库develop git checkout -b dev 建立一个新的本地分支dev git merge origin/dev 将分支dev与当前分支进行合并 git checkout dev 切换到本地dev分支 git remote show 查看远程库 git add . git rm 文件名(包括路径) 从git中删除指定文件 git clone git://github.com/schacon/grit.git 从服务器上将代码给拉下来 git config --list 看所有用户 git ls-files 看已经被提交的 git rm [file name] 删除一个文件 git commit -a 提交当前repos的所有的改变 git add [file name] 添加一个文件到git index git commit -v 当你用－v参数的时候可以看commit的差异 git commit -m \u0026quot;This is the message describing the commit\u0026quot; 添加commit信息 git commit -a -a是代表add，把所有的change加到git index里然后再commit git commit -a -v 一般提交命令 git log 看你commit的日志 git diff 查看尚未暂存的更新 git rm a.a 移除文件(从暂存区和工作区中删除) git rm --cached a.a 移除文件(只从暂存区中删除) git commit -m \u0026quot;remove\u0026quot; 移除文件(从Git中删除) git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除) git diff --cached 或 $ git diff --staged 查看尚未提交的更新 git stash push 将文件给push到一个临时空间中 git stash pop 将文件从临时空间pop下来 # ------------------------------------------------------- git remote add origin git@github.com:username/Hello-World.git git push origin master 将本地项目给提交到服务器中 # ------------------------------------------------------- git pull 本地与服务器端同步 # --------------------------------------------------------------- git push (远程仓库名) (分支名) 将本地分支推送到服务器上去。 git push origin serverfix:awesomebranch # ---------------------------------------------------------------- git fetch 相当于是从远程获取最新版本到本地，不会自动merge git commit -a -m \u0026quot;log_message\u0026quot; (-a是提交所有改动，-m是加入log信息) 本地修改同步至服务器端 ： git branch branch_0.1 master 从主分支master创建branch_0.1分支 git branch -m branch_0.1 branch_1.0 将branch_0.1重命名为branch_1.0 git checkout branch_1.0/master 切换到branch_1.0/master分支 du -hs # --------------------------------------------------------- mkdir WebApp cd WebApp git init touch README git add README git commit -m 'first commit' git remote add origin git@github.com:daixu/WebApp.git git push -u origin master **Git 常用命令图表 ** 转自：http://blog.csdn.net/dengsilinming/article/details/8000622 ","id":12,"section":"posts","summary":"Git常用操作命令： 1) 远程仓库相关命令 # 检出仓库： $ git clone git://github.com/jquery/jquery.git #查看远程仓库： $ git remote -v # 添加远程仓库： $ git remote add [name] [url] # 删除远程仓库： $ git remote rm [name] # 修","tags":["git"],"title":"Git 常用命令","uri":"https://blog.fengjx.com/git/","year":"2016"},{"content":"git-flow工作流程 当在团队开发中使用版本控制系统时，商定一个统一的工作流程是至关重要的。Git 的确可以在各个方面做很多事情，然而，如果在你的团队中还没有能形成一个特定有效的工作流程，那么混乱就将是不可避免的。\n基本上你可以定义一个完全适合你自己项目的工作流程，或者使用一个别人定义好的。\n在这章节中我们将一起学习一个当前非常流行的工作流程 git-flow。\n什么是 git-flow？ 一旦安装安装 git-flow，你将会拥有一些扩展命令。这些命令会在一个预定义的顺序下自动执行多个操作。是的，这就是我们的工作流程！\ngit-flow 并不是要替代 Git，它仅仅是非常聪明有效地把标准的 Git 命令用脚本组合了起来。\n严格来讲，你并不需要安装什么特别的东西就可以使用 git-flow 工作流程。你只需要了解，哪些工作流程是由哪些单独的任务所组成的，并且附带上正确的参数，以及在一个正确的顺序下简单执行那些对应的 Git 命令就可以了。当然，如果你使用 git-flow 脚本就会更加方便了，你就不需要把这些命令和顺序都记在脑子里。\n安装 git-flow 近些年来出现了很多不同的安装方法。在本章节中我们会使用当前最流行的一种： AVH Edition。\n要了解安装 git-flow 细节，请阅读下面这个文档 official documentation。\n在项目中设置 git-flow 当你想把你的项目 “切换” 到 git-flow 上后，Git 还是可以像往常一样工作的。这完全是取决于你在仓库上使用特殊的 git-flow 命令或是普通的 Git 命令。换句话说，git-flow 它不会以任何一种戏剧性的方式来改变你的仓库。\n话虽如此，git-flow 却存在一些限制。让我们开始在一个新的项目上初始化它吧，之后我们就会有所发现：\n$ git flow init Initialized empty Git repository in /Users/tobi/acme-website/.git/ Branch name for production releases: [master] Branch name for \u0026quot;next release\u0026quot; development: [develop] How to name your supporting branch prefixes? Feature branches? [feature/] Release branches? [release/] Hotfix branches? [hotfix/] 当在项目的根目录执行 “git flow init” 命令时（它是否已经包括了一个 Git 仓库并不重要），一个交互式安装助手将引导您完成这个初始化操作。听起来是不是有点炫，但实际上它只是在你的分支上配置了一些命名规则。 尽管如此，这个安装助手还是允许你使用自己喜欢的名字。我强烈建议你使用默认的命名机制，并且一步一步地确定下去。\n分支的模式 git-flow 模式会预设两个主分支在仓库中：\n master 只能用来包括产品代码。你不能直接工作在这个 master 分支上，而是在其他指定的，独立的特性分支中（这方面我们会马上谈到）。不直接提交改动到 master 分支上也是很多工作流程的一个共同的规则。 develop 是你进行任何新的开发的基础分支。当你开始一个新的功能分支时，它将是_开发_的基础。另外，该分支也汇集所有已经完成的功能，并等待被整合到 master 分支中。  这两个分支被称作为 长期分支。它们会存活在项目的整个生命周期中。而其他的分支，例如针对功能的分支，针对发行的分支，仅仅只是临时存在的。它们是根据需要来创建的，当它们完成了自己的任务之后就会被删除掉。\n让我们开始探索一些在现实应用中可能遇到的案例吧！\n功能开发 对于一个开发人员来说，最平常的工作可能就是功能的开发。这就是为什么 git-flow 定义了很多对于功能开发的工作流程，从而来帮助你有组织地完成它。\n开始新功能 让我们开始开发一个新功能 “rss-feed”：\n$ git flow feature start rss-feed Switched to a new branch 'feature/rss-feed' Summary of actions: - A new branch 'feature/rss-feed' was created, based on 'develop' - You are now on branch 'feature/rss-feed' 概念 在这些命令的输出文本中，git-flow 会对刚刚完成的操作打印出一个很有帮助的概述\n当你需要帮助的时候，你可以随时请求帮助。例如：\n$ git flow feature help 正如上面这个新功能一样，git-flow 会创建一个名为 “feature/rss-feed” 的分支（这个 “feature/” 前缀 是一个可配置的选项设置）。你已经知道了，在你做新功能开发时使用一个独立的分支是版本控制中最重要的规则之一。 git-flow 也会直接签出这个新的分支，这样你就可以直接进行工作了。\n完成一个功能 经过一段时间艰苦地工作和一系列的聪明提交，我们的新功能终于完成了：\n$ git flow feature finish rss-feed Switched to branch 'develop' Updating 6bcf266..41748ad Fast-forward feed.xml | 0 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 feed.xml Deleted branch feature/rss-feed (was 41748ad). 最重要的是，这个 “feature finish” 命令会把我们的工作整合到主 “develop” 分支中去。在这里它需要等待：\n 一个在更广泛的 “开发” 背景下的全面测试。 稍后和所有积攒在 “develop” 分支中的其它功能一起进行发布。  之后，git-flow 也会进行清理操作。它会删除这个当下已经完成的功能分支，并且换到 “develop” 分支。\n管理 releases Release 管理是版本控制处理中的另外一个非常重要的话题。让我们来看看如何利用 git-flow 创建和发布 release。\n创建 release 当你认为现在在 “develop” 分支的代码已经是一个成熟的 release 版本时，这意味着：第一，它包括所有新的功能和必要的修复；第二，它已经被彻底的测试过了。如果上述两点都满足，那就是时候开始生成一个新的 release 了：\n$ git flow release start 1.1.5 Switched to a new branch 'release/1.1.5' 请注意，release 分支是使用版本号命名的。这是一个明智的选择，这个命名方案还有一个很好的附带功能，那就是当我们完成了release 后，git-flow 会适当地_自动_去标记那些 release 提交。\n有了一个 release 分支，再完成针对 release 版本号的最后准备工作（如果项目里的某些文件需要记录版本号），并且进行最后的编辑。\n完成 release 现在是时候按下那个危险的红色按钮来完成我们的release了：\ngit flow release finish 1.1.5 这个命令会完成如下一系列的操作：\n 首先，git-flow 会拉取远程仓库，以确保目前是最新的版本。 然后，release 的内容会被合并到 “master” 和 “develop” 两个分支中去，这样不仅产品代码为最新的版本，而且新的功能分支也将基于最新代码。 为便于识别和做历史参考，release 提交会被标记上这个 release 的名字（在我们的例子里是 “1.1.5”）。 清理操作，版本分支会被删除，并且回到 “develop”。  从 Git 的角度来看，release 版本现在已经完成。依据你的设置，对 “master” 的提交可能已经触发了你所定义的部署流程，或者你可以通过手动部署，来让你的软件产品进入你的用户手中。\nhotfix 很多时候，仅仅在几个小时或几天之后，当对 release 版本作做全面测试时，可能就会发现一些小错误。 在这种情况下，git-flow 提供一个特定的 “hotfix” 工作流程（因为在这里不管使用 “功能” 分支流程，还是 “release” 分支流程都是不恰当的）。\n创建 Hotfixes $ git flow hotfix start missing-link 这个命令会创建一个名为 “hotfix/missing-link” 的分支。因为这是对产品代码进行修复，所以这个 hotfix 分支是基于 “master” 分支。 这也是和 release 分支最明显的区别，release 分支都是基于 “develop” 分支的。因为你不应该在一个还不完全稳定的开发分支上对产品代码进行地修复。\n就像 release 一样，修复这个错误当然也会直接影响到项目的版本号！\n完成 Hotfixes 在把我们的修复提交到 hotfix 分支之后，就该去完成它了：\n$ git flow hotfix finish missing-link 这个过程非常类似于发布一个 release 版本：\n 完成的改动会被合并到 “master” 中，同样也会合并到 “develop” 分支中，这样就可以确保这个错误不会再次出现在下一个 release 中。 这个 hotfix 程序将被标记起来以便于参考。 这个 hotfix 分支将被删除，然后切换到 “develop” 分支上去。  还是和产生 release 的流程一样，现在需要编译和部署你的产品（如果这些操作不是自动被触发的话）。\n回顾一下 最后，在结束这个章节之前，我要再次强调几个重点。 首先，git-flow 并不会为 Git 扩展任何新的功能，它仅仅使用了脚本来捆绑了一系列 Git 命令来完成一些特定的工作流程。 其次，定义一个固定的工作流程会使得团队协作更加简单容易。无论是一个 “版本控制的新手” 还是 “Git 专家”，每一个人都知道如何来正确地完成某个任务。\n记住，使用 git-flow 并不是必须的。当积攒了一定的使用经验后，很多团队会不再需要它了。当你能正确地理解工作流程的基本组成部分和目标的之后，你完全可以定义一个属于你自己的工作流程。\n完整流程图 原文链接：https://www.git-tower.com/learn/git/ebook/cn/command-line/advanced-topics/git-flow\n","id":13,"section":"posts","summary":"git-flow工作流程 当在团队开发中使用版本控制系统时，商定一个统一的工作流程是至关重要的。Git 的确可以在各个方面做很多事情，然而，如果","tags":["git"],"title":"git-flow工作流程","uri":"https://blog.fengjx.com/git-flow/","year":"2016"},{"content":"\\r command not found 解决办法 当我们执行shell脚本的时候提示\u0026rsquo;\\r\u0026rsquo;: command not found，但是检查了很多次并没有发现什么问题。\n原因是windows下的换行符是\\r\\n，而linux下的换行符是\\n，所以只要执行下面的命令把\\r去掉就可以了。\n#转化为unix格式 sed -i \u0026#39;s/\\r$//\u0026#39; \u0026lt;filename\u0026gt; 附：# Linux中使用sed命令替换字符串小结 sed替换的基本语法为:\nsed \u0026lsquo;s/原字符串/替换字符串/\u0026rsquo;\n单引号里面,s表示替换,三根斜线中间是替换的样式,特殊字符需要使用反斜线”\\”进行转义,但是单引号”‘”是没有办法用反斜线”\\”转义的,这时候只要把命令中的单引号改为双引号就行了,例如:\nsed \u0026ldquo;s/原字符串包含\u0026rsquo;/替换字符串包含\u0026rsquo;/\u0026rdquo; //要处理的字符包含单引号\n命令中的三根斜线分隔符可以换成别的符号,这在要替换的内容有较多斜线是较为方便,只需要紧跟s定义即可,例如换成问号”?”:\nsed \u0026lsquo;s?原字符串?替换字符串?\u0026rsquo; //自定义分隔符为问号\n可以在末尾加g替换每一个匹配的关键字,否则只替换每行的第一个,例如:\nsed \u0026lsquo;s/原字符串/替换字符串/\u0026rsquo; //替换所有匹配关键字\n上箭头”^”表示行首,美元”$”符号如果在引号中表示行尾,但是在引号外却表示末行(最后一行),这里犯二了,搜了半天哪个符号表示首行,半天才想起来,首行就是数字”1″啊.那么在行首和行尾添加字符串就是把行尾和行首替换,例如:\nsed \u0026lsquo;s/^/添加的头部\u0026amp;/g\u0026rsquo; //在所有行首添加 sed \u0026lsquo;s/$/\u0026amp;添加的尾部/g\u0026rsquo; //在所有行末添加 sed \u0026lsquo;2s/原字符串/替换字符串/g\u0026rsquo; //替换第2行 sed \u0026lsquo;$s/原字符串/替换字符串/g\u0026rsquo; //替换最后一行 sed \u0026lsquo;2,5s/原字符串/替换字符串/g\u0026rsquo; //替换2到5行 sed \u0026lsquo;2,$s/原字符串/替换字符串/g\u0026rsquo; //替换2到最后一行\n替换样式可以多个在同一条命令中执行,用分号”;”分隔,例如:\nsed \u0026lsquo;s/^/添加的头部\u0026amp;/g；s/$/\u0026amp;添加的尾部/g\u0026rsquo; //同时执行两个替换规则\nsed处理过的输出是直接输出到屏幕上的,要保存可以将输出重定向,或者使用参数”i”直接在文件中替换:\nsed -i \u0026lsquo;s/原字符串/替换字符串/g\u0026rsquo; filename //替换文件中的所有匹配项\n","id":14,"section":"posts","summary":"\\r command not found 解决办法 当我们执行shell脚本的时候提示\u0026rsquo;\\r\u0026rsquo;: command not found，但是检查了很多次并没有发现什么问题。 原因","tags":["linux"],"title":"\r command not found 解决办法","uri":"https://blog.fengjx.com/shell-command-not-found/","year":"2016"}],"tags":[{"title":"curl","uri":"https://blog.fengjx.com/tags/curl/"},{"title":"docker","uri":"https://blog.fengjx.com/tags/docker/"},{"title":"eclipse","uri":"https://blog.fengjx.com/tags/eclipse/"},{"title":"ffmpeg","uri":"https://blog.fengjx.com/tags/ffmpeg/"},{"title":"git","uri":"https://blog.fengjx.com/tags/git/"},{"title":"google","uri":"https://blog.fengjx.com/tags/google/"},{"title":"index","uri":"https://blog.fengjx.com/tags/index/"},{"title":"io","uri":"https://blog.fengjx.com/tags/io/"},{"title":"java8","uri":"https://blog.fengjx.com/tags/java8/"},{"title":"jvm","uri":"https://blog.fengjx.com/tags/jvm/"},{"title":"LibreOffice","uri":"https://blog.fengjx.com/tags/libreoffice/"},{"title":"linux","uri":"https://blog.fengjx.com/tags/linux/"},{"title":"mac","uri":"https://blog.fengjx.com/tags/mac/"},{"title":"manjaro","uri":"https://blog.fengjx.com/tags/manjaro/"},{"title":"mysql","uri":"https://blog.fengjx.com/tags/mysql/"},{"title":"netty","uri":"https://blog.fengjx.com/tags/netty/"},{"title":"npm","uri":"https://blog.fengjx.com/tags/npm/"},{"title":"openresty","uri":"https://blog.fengjx.com/tags/openresty/"},{"title":"socket","uri":"https://blog.fengjx.com/tags/socket/"},{"title":"supervisor","uri":"https://blog.fengjx.com/tags/supervisor/"},{"title":"ububtu","uri":"https://blog.fengjx.com/tags/ububtu/"},{"title":"yarn","uri":"https://blog.fengjx.com/tags/yarn/"},{"title":"zookeeper","uri":"https://blog.fengjx.com/tags/zookeeper/"},{"title":"多线程","uri":"https://blog.fengjx.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]}